// Generated by CoffeeScript 1.6.3
var baseSieve, createBaseSieve, inputLang, markers, tokenizeMarker, util, verbex;

util = require('./util');

verbex = require('verbal-expressions');

inputLang = {};

inputLang.anything = verbex().then('..').maybe('.').maybe('.').maybe('.');

markers = {};

markers.array = [];

baseSieve = [];

exports.baseSieve = baseSieve;

tokenizeMarker = function(marker) {
  var char, i, insideDelimiter, insideWord, sanitizeMarker, string, tokens, word, _i, _ref;
  sanitizeMarker = function(marker) {
    if (inputLang.anything.test(marker.WordOrPattern)) {
      console.log('Marker anything input indicator found in: ' + marker.WordOrPattern);
      marker.WordOrPattern = marker.WordOrPattern.replace(inputLang.anything, '\\*');
      return console.log('Replaced anything indicator to:           ' + marker.WordOrPattern);
    }
  };
  sanitizeMarker(marker);
  string = marker.WordOrPattern;
  insideWord = false;
  insideDelimiter = false;
  tokens = [];
  if (string.length === 0) {
    return [];
  }
  for (i = _i = 0, _ref = string.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    char = string.charAt(i);
    if (util.isAnySpaceChar(char)) {
      if (insideWord) {
        tokens.push({
          'metaType': 'regular',
          'text': word
        });
        insideWord = false;
      }
      if (!insideDelimiter) {
        tokens.push({
          'metaType': 'delimiter'
        });
        insideDelimiter = true;
      }
    } else {
      if (insideDelimiter) {
        insideDelimiter = false;
      }
      if (insideWord) {
        word = word.concat(char);
      } else {
        word = char;
        insideWord = true;
      }
    }
  }
  if (insideWord) {
    tokens.push({
      'metaType': 'regular',
      'text': word
    });
  }
  return tokens;
};

exports.createDocumentSieve = function(baseSieve) {
  var baseSieveRow, k, sieve, sieveRow, _i, _len;
  sieve = [];
  for (_i = 0, _len = baseSieve.length; _i < _len; _i++) {
    baseSieveRow = baseSieve[_i];
    sieveRow = {};
    for (k in baseSieveRow) {
      sieveRow[k] = baseSieveRow[k];
      sieve.push(sieveRow);
    }
  }
  return sieve;
};

createBaseSieve = function(callback) {
  var add, marker, markerId, seiveRow, _i, _len, _ref;
  add = function(string, addition) {
    return string + addition;
  };
  markerId = 0;
  util.timelog('Markers visualization');
  _ref = markers.array;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    marker = _ref[_i];
    seiveRow = {};
    seiveRow.markerTokens = tokenizeMarker(marker);
    seiveRow.markerId = markerId;
    baseSieve.push(seiveRow);
    markerId += 1;
  }
  util.timelog('Markers visualization');
  return callback();
};

exports.load = function(callback) {
  var csvConverter, csvFile, csvToJsonConverter;
  util.timelog('Loading markers');
  csvToJsonConverter = require('csvtojson').core.Converter;
  csvConverter = new csvToJsonConverter();
  csvConverter.on("end_parsed", function(jsonFromCss) {
    markers.array = jsonFromCss.csvRows;
    util.timelog('Sorting markers');
    markers.array.sort(function(a, b) {
      if (a.WordOrPattern > b.WordOrPattern) {
        return 1;
      } else {
        return -1;
      }
    });
    util.timelog('Sorting markers');
    util.timelog('Loading markers');
    return createBaseSieve(callback);
  });
  csvFile = './markers.csv';
  return csvConverter.from(csvFile);
};
