// Generated by CoffeeScript 1.6.3
var baseSieve, createBaseSieve, inputLang, internalLang, markers, tokenizeMarker, util, verbex;

util = require('./util');

verbex = require('verbal-expressions');

inputLang = {};

inputLang.oneOrMoreWords = verbex().then('..').maybe('.').maybe('.').maybe('.');

internalLang = {};

internalLang.oneOrMoreWords = '\\*';

markers = {};

markers.array = [];

baseSieve = [];

exports.baseSieve = baseSieve;

tokenizeMarker = function(marker) {
  var char, i, insideDelimiter, insideWord, sanitizeMarker, string, token, tokens, word, _i, _j, _len, _ref;
  sanitizeMarker = function(marker) {
    if (inputLang.oneOrMoreWords.test(marker.WordOrPattern)) {
      return marker.WordOrPattern = marker.WordOrPattern.replace(inputLang.oneOrMoreWords, internalLang.oneOrMoreWords);
    }
  };
  sanitizeMarker(marker);
  string = marker.WordOrPattern;
  insideWord = false;
  insideDelimiter = false;
  tokens = [];
  if (string.length === 0) {
    return [];
  }
  for (i = _i = 0, _ref = string.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    char = string.charAt(i);
    if (util.isAnySpaceChar(char)) {
      if (insideWord) {
        tokens.push({
          'metaType': 'regular',
          'text': word
        });
        insideWord = false;
      }
      if (!insideDelimiter) {
        tokens.push({
          'metaType': 'delimiter'
        });
        insideDelimiter = true;
      }
    } else {
      if (insideDelimiter) {
        insideDelimiter = false;
      }
      if (insideWord) {
        word = word.concat(char);
      } else {
        word = char;
        insideWord = true;
      }
    }
  }
  if (insideWord) {
    tokens.push({
      'metaType': 'regular',
      'text': word
    });
  }
  for (_j = 0, _len = tokens.length; _j < _len; _j++) {
    token = tokens[_j];
    if (token.metaType === 'regular' && token.text === internalLang.oneOrMoreWords) {
      delete token.text;
      token.metaType = 'anyOneOrMore';
    }
  }
  tokens = tokens.filter(function(token) {
    return token.metaType !== 'delimiter';
  });
  return tokens;
};

exports.createDocumentSieve = function(baseSieve) {
  var baseSieveRow, k, sieve, sieveRow, _i, _len;
  sieve = [];
  for (_i = 0, _len = baseSieve.length; _i < _len; _i++) {
    baseSieveRow = baseSieve[_i];
    sieveRow = {};
    for (k in baseSieveRow) {
      sieveRow[k] = baseSieveRow[k];
      sieve.push(sieveRow);
    }
  }
  return sieve;
};

createBaseSieve = function(callback) {
  var add, marker, markerId, seiveRow, _i, _len, _ref;
  add = function(string, addition) {
    return string + addition;
  };
  markerId = 0;
  util.timelog('Markers visualization');
  _ref = markers.array;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    marker = _ref[_i];
    seiveRow = {};
    seiveRow.markerTokens = tokenizeMarker(marker);
    seiveRow.markerId = markerId;
    baseSieve.push(seiveRow);
    markerId += 1;
  }
  util.timelog('Markers visualization');
  return callback();
};

exports.load = function(callback) {
  var csvConverter, csvFile, csvToJsonConverter;
  util.timelog('Loading markers');
  csvToJsonConverter = require('csvtojson').core.Converter;
  csvConverter = new csvToJsonConverter();
  csvConverter.on("end_parsed", function(jsonFromCss) {
    markers.array = jsonFromCss.csvRows;
    util.timelog('Sorting markers');
    markers.array.sort(function(a, b) {
      if (a.WordOrPattern > b.WordOrPattern) {
        return 1;
      } else {
        return -1;
      }
    });
    util.timelog('Sorting markers');
    util.timelog('Loading markers');
    return createBaseSieve(callback);
  });
  csvFile = './markers.csv';
  return csvConverter.from(csvFile);
};
