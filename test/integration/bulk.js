// Generated by CoffeeScript 1.6.3
var aggregateWait, directory, filename, fs, host, http, logging, makeRequest, nconf, port, requests, responses, serial, toRequest, util, _i, _j, _len, _len1, _ref;

http = require('http');

fs = require('fs');

nconf = require('nconf');

util = require('../../src/util/util');

logging = require('../../src/util/logging');

nconf.argv().env();

nconf.defaults({
  host: "localhost",
  serial: true
});

host = nconf.get('host');

logging.logGreen('Using hostname ' + nconf.get('host'));

port = process.env.PORT || 3080;

logging.logGreen('Using port ' + port);

serial = nconf.get("serial");

switch (serial) {
  case false:
    logging.logGreen('Running in concurrent mode');
    break;
  case true:
    logging.logGreen('Running in serial mode');
    break;
  default:
    logging.logYellow("Invalid value supplied for the --serial argument, value can only be true or false");
    process.exit(0);
}

logging.logGreen("Running against host " + host + ", port " + port + " ...");

logging.logGreen('');

http.globalAgent.maxSockets = 1000;

directory = '../local-copies/pdf/';

requests = 0;

responses = 0;

aggregateWait = 0;

makeRequest = function(filename) {
  var httpCallBack;
  requests += 1;
  httpCallBack = (function(filename) {
    return function(res) {
      var responseBody;
      responses += 1;
      responseBody = '';
      res.on('data', function(chunk) {
        return responseBody += chunk;
      });
      return res.on('end', function() {
        var requestElapsedTime;
        if (res.statusCode === 200) {
          logging.logGreen('Server response for ' + filename + ' is:   ' + res.statusCode);
        } else {
          logging.logYellow('Server response for ' + filename + ' is:   ' + res.statusCode + ', ' + responseBody);
        }
        if (serial) {
          toRequest.shift();
          if (toRequest.length > 0) {
            makeRequest(toRequest[0]);
          }
        }
        console.log(responses + ' responses out of ' + requests + ' requests received thus far');
        requestElapsedTime = util.timelog(null, 'Server response for ' + filename);
        aggregateWait += requestElapsedTime / 1000;
        if (responses === requests) {
          logging.logPerf('');
          util.timelog(null, 'Overall');
          logging.logPerf('');
          logging.logPerf('-----------------------------');
          logging.logPerf('Aggregate response await time');
          logging.logPerf('time:       ' + aggregateWait + ' secs');
          logging.logPerf('normalized: ' + (aggregateWait / responses));
          logging.logPerf('');
          process.exit(0);
        }
      });
    };
  })(filename);
  console.log("Requesting " + directory + filename);
  util.timelog(null, 'Server response for ' + filename);
  return http.get({
    host: host,
    port: port,
    path: '/handleInputFile?' + 'localLocation=' + encodeURIComponent(filename),
    method: 'GET'
  }, httpCallBack).on('error', function(e) {
    return console.log("Got error: " + e.message);
  });
};

util.timelog(null, 'Overall');

toRequest = [];

_ref = fs.readdirSync(directory);
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  filename = _ref[_i];
  if (fs.statSync(directory + filename).isFile()) {
    if (filename !== '.gitignore') {
      toRequest.push(filename);
    } else {
      console.log('Skipping .gitignore');
    }
  } else {
    console.log('Skipping subdirectory ' + filename);
  }
}

if (toRequest.length > 0) {
  if (serial) {
    makeRequest(toRequest[0]);
  } else {
    for (_j = 0, _len1 = toRequest.length; _j < _len1; _j++) {
      filename = toRequest[_j];
      makeRequest(filename);
    }
  }
} else {
  logging.logYellow('No files to process in directory. Existing.');
}
