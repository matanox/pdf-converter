// Generated by CoffeeScript 1.6.3
var closer, docDataDir, files, logging, util, winston, winstonWrite;

logging = require('./logging');

winston = require('winston');

util = require('./util');

docDataDir = 'docData/';

exports.docDataDir = docDataDir;

files = {};

winstonWrite = function(writer, data) {
  return writer.info(data);
};

exports.write = function(inputFileName, dataType, data) {
  var nameBase, now, writer;
  if (files[inputFileName] == null) {
    files[inputFileName] = {};
  }
  if (files[inputFileName][dataType] == null) {
    writer = new winston.Logger;
    now = new Date();
    console.log("opening writer for " + dataType);
    util.mkdir(docDataDir, inputFileName);
    nameBase = docDataDir + '/' + inputFileName + '/' + dataType + '-' + now.toISOString() + '.out';
    writer = new winston.Logger({
      transports: [
        new winston.transports.File({
          name: 'file#text',
          filename: nameBase,
          json: false,
          timestamp: false
        })
      ],
      exitOnError: false
    });
    logging.cond("Data writing for [" + inputFileName + "], [" + dataType + "] is going to " + nameBase, 'dataWriter');
    files[inputFileName][dataType] = writer;
  }
  winstonWrite(files[inputFileName][dataType], data);
  return true;
};

closer = function(inputFileName) {
  var writer;
  console.log("closing writers for " + inputFileName);
  for (writer in files[inputFileName]) {
    if (files[inputFileName][writer].transports['file#text'].opening) {
      console.warn('cannot close writer as it has not drained. queuing a retry.');
      setTimeout((function() {
        return closer(inputFileName);
      }), 2000);
      return;
    } else {
      files[inputFileName][writer].close();
      delete files[inputFileName][writer];
    }
  }
};

exports.close = function(inputFileName) {
  return setTimeout((function() {
    return closer(inputFileName);
  }), 2000);
};
