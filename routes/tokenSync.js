// Generated by CoffeeScript 1.6.3
var Sync, css, extract, logging, riak, serveTokens, storage, util;

util = require('../src/util');

logging = require('../src/logging');

css = require('../src/css');

storage = require('../src/storage');

require('stream');

riak = require('riak-js').getClient({
  host: "localhost",
  port: "8098"
});

extract = require('./extract');

Sync = require('sync');

serveTokens = function(req, res) {
  var serializedTokens;
  if (req.session.serializedTokens != null) {
    serializedTokens = req.session.serializedTokens;
  } else {
    util.timelog('pickling');
    serializedTokens = JSON.stringify(req.session.tokens);
    console.log("" + req.session.tokens.length + " tokens pickled into " + serializedTokens.length + " long bytes stream");
    console.log("pickled size to tokens ratio: " + (parseFloat(serializedTokens.length) / req.session.tokens.length));
    util.timelog('pickling');
    console.log('saving tokens to data store');
    storage.store('tokens', req.session.name, serializedTokens, req.session.docLogger);
    req.session.serializedTokens = serializedTokens;
  }
  /*
  tokens = []
  paragraphOpeningDelimitation = { metaType: 'paragraphBreak' }
  for x in req.session.tokens 
    if x.metaType is 'regular'
      if x.paragraph is 'opener'
        tokens.push(paragraphOpeningDelimitation) # a bit superfluous right now
                                                         # or just lame doing it here
    tokens.push(x)
  */

  return res.end(serializedTokens);
};

exports.go = function(req, res) {
  var docLogger, filtered, removed, serializedTokens, t, tokens, _i, _ref;
  util.timelog("handling client ajax request for " + req.session.name);
  if (Object.keys(req.body).length === 0) {
    if ((req.query.regenerate != null) || (req.session.serializedTokens == null)) {
      console.log('generating tokens');
      if (req.session.name == null) {
        req.session.name = 'LaeUusATIi5FHXHmF4hU';
      }
      docLogger = util.initDocLogger(req.session.name);
      return extract.generateFromHtml(req, req.session.name, res, docLogger, function() {
        return serveTokens(req, res);
      });
    } else {
      return serveTokens(req, res);
    }
  } else {
    console.log("ajax request body length is " + req.body.length);
    tokens = req.body;
    console.log('received updated tokens from client');
    util.timelog('saving updated tokens to data store');
    removed = 0;
    filtered = [];
    for (t = _i = 0, _ref = tokens.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; t = 0 <= _ref ? ++_i : --_i) {
      if (tokens[t].remove) {
        removed += 1;
      } else {
        filtered.push(tokens[t]);
      }
    }
    tokens = filtered;
    console.log("removed " + removed + " tokens marked for removal by client request");
    util.timelog('pickling');
    serializedTokens = JSON.stringify(tokens);
    util.timelog('pickling');
    storage.store('tokens', req.session.name, serializedTokens, req.session.docLogger);
    util.timelog('saving updated tokens to data store');
    req.session.serializedTokens = serializedTokens;
    req.session.tokens = tokens;
    return res.end('success');
  }
};
