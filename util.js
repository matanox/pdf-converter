// Generated by CoffeeScript 1.6.3
var anySpaceChar, clone, contains, endsWith, fs, isAnyOf, logging, startsWith, timelog, winston;

fs = require('fs');

logging = require('./logging');

winston = require('winston');

anySpaceChar = RegExp(/\s/);

exports.htmlCharacterEntity = RegExp(/&.*\b;$/);

exports.anySpaceChar = anySpaceChar;

endsWith = function(string, match) {
  return string.lastIndexOf(match) === string.length - match.length;
};

exports.endsWith = endsWith;

startsWith = function(string, match) {
  return string.indexOf(match) === 0;
};

exports.startsWith = startsWith;

contains = function(string, match) {
  return string.indexOf(match) !== -1;
};

exports.strip = function(string, prefix, suffix) {
  if (!startsWith(string, prefix)) {
    throw "Cannot strip string of the supplied prefix";
  }
  if (!endsWith(string, suffix)) {
    throw "Cannot strip string of the supplied suffix";
  }
  return string.slice(string.indexOf(prefix) + prefix.length, string.lastIndexOf(suffix));
};

isAnyOf = function(string, matches) {
  return matches.some(function(elem) {
    return elem.localeCompare(string, 'en-US') === 0;
  });
};

exports.isAnyOf = isAnyOf;

exports.unique = function(array, preserveFloat) {
  var item, key, result, temp, value, _i, _len;
  temp = {};
  result = [];
  for (_i = 0, _len = array.length; _i < _len; _i++) {
    item = array[_i];
    temp[item] = true;
  }
  for (key in temp) {
    value = temp[key];
    if (preserveFloat) {
      result.push(parseFloat(key));
    } else {
      result.push(key);
    }
  }
  return result;
};

exports.objectPropertiesCount = function(object) {
  return Object.keys(object).length;
};

exports.endsWithAnyOf = function(string, matches) {
  var trailingChar;
  trailingChar = string.charAt(string.length - 1);
  if (!isAnyOf(trailingChar, matches)) {
    return false;
  }
  return trailingChar;
};

exports.startsWithAnyOf = function(string, matches) {
  var char;
  char = string.charAt(0);
  if (!isAnyOf(char, matches)) {
    return false;
  }
  return char;
};

exports.isAnySpaceChar = function(char) {
  return anySpaceChar.test(char);
};

exports.isSpaceCharsOnly = function(string) {
  var i, _i, _ref;
  for (i = _i = 0, _ref = string.length() - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (!isAnySpaceChar(string.charAt[i])) {
      return false;
    }
  }
  return true;
};

exports.lastChar = function(string) {
  return string.charAt(string.length - 1);
};

exports.last = function(array) {
  return array[array.length - 1];
};

exports.first = function(array) {
  return array[0];
};

exports.parseElementTextOld = function(xmlNode) {
  var content;
  content = xmlNode.substr(0, xmlNode.length - "</div>".length);
  content = content.slice(content.indexOf(">") + 1);
  return content;
};

exports.logObject = function(obj) {
  return logging.log(JSON.stringify(obj, null, 2));
};

timelog = function(timer, logger) {
  var elapsed, end, start;
  if (timelog.timersLookup == null) {
    timelog.timersLookup = {};
  }
  if (timelog.timersLookup[timer] != null) {
    end = new Date();
    elapsed = end.getTime() - timelog.timersLookup[timer];
    if (logger != null) {
      logger.info(timer + ' took: ' + elapsed + ' ms');
    } else {
      logging.log(timer + ' took: ' + elapsed + ' ms');
    }
    delete timelog.timersLookup[timer];
    return elapsed;
  } else {
    start = new Date();
    timelog.timersLookup[timer] = start.getTime();
    return null;
  }
};

exports.timelog = timelog;

exports.objectViolation = function(errorMessage) {
  var error;
  error = new Error(errorMessage);
  logging.log(error.stack);
  throw error;
};

clone = function(obj) {
  var key, newInstance;
  if ((obj == null) || typeof obj !== 'object') {
    return obj;
  }
  newInstance = {};
  for (key in obj) {
    newInstance[key] = clone(obj[key]);
  }
  return newInstance;
};

exports.clone = clone;

exports.pushIfTrue = function(array, functionResult) {
  if (functionResult) {
    array.push(functionResult);
    return true;
  }
  return false;
};

exports.simpleLogSequence = function(tokens, sequence, heading) {
  var output, t, token, _i, _ref, _ref1;
  if (heading != null) {
    console.log(heading + ':');
  }
  output = '';
  for (t = _i = _ref = sequence.startToken, _ref1 = sequence.endToken; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; t = _ref <= _ref1 ? ++_i : --_i) {
    token = tokens[t];
    if (token.text != null) {
      output += token.text;
    } else {
      output += ' ';
    }
  }
  return console.log(output);
};

exports.markTokens = function(tokens, sequence, mark) {
  var t, token, _i, _ref, _ref1, _results;
  _results = [];
  for (t = _i = _ref = sequence.startToken, _ref1 = sequence.endToken; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; t = _ref <= _ref1 ? ++_i : --_i) {
    token = tokens[t];
    _results.push(token.meta = mark);
  }
  return _results;
};

exports.initDocLogger = function(name) {
  var docLogger, docLoggerNameBase, now;
  docLogger = new winston.Logger;
  now = new Date();
  docLoggerNameBase = 'logs/' + name + '-' + now.toISOString() + '.log';
  /*
  docLogger.add(winston.transports.File, {
    filename: docLoggerNameBase + '.json',
    json: true
    timestamp: true})
  */

  docLogger = new winston.Logger({
    transports: [
      new winston.transports.File({
        name: 'file#json',
        filename: docLoggerNameBase + '.json',
        json: true,
        timestamp: true
      }), new winston.transports.File({
        name: 'file#text',
        filename: docLoggerNameBase,
        json: false,
        timestamp: true
      })
    ],
    exitOnError: false
  });
  console.log('Logging handling of ' + name + ' in ' + docLoggerNameBase + '*');
  return docLogger;
};

exports.initDataWriter = function(dirName, fileName) {
  var docLogger, err, nameBase, now;
  docLogger = new winston.Logger;
  now = new Date();
  try {
    fs.mkdirSync('outputs/' + dirName);
  } catch (_error) {
    err = _error;
    if (err.code !== 'EEXIST') {
      throw e;
    }
  }
  nameBase = 'outputs/' + dirName + '/' + fileName + '-' + now.toISOString() + '.out';
  docLogger = new winston.Logger({
    transports: [
      new winston.transports.File({
        name: 'file#json',
        filename: nameBase + '.json',
        json: true,
        timestamp: true
      }), new winston.transports.File({
        name: 'file#text',
        filename: nameBase,
        json: false,
        timestamp: true
      })
    ],
    exitOnError: false
  });
  return docLogger;
};
