<!DOCTYPE html>
<!-- Created by pdf2htmlEX (https://github.com/coolwanglu/pdf2htmlex) -->
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="pdf2htmlEX">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<link rel="stylesheet" href="base.min.css"/>
<link rel="stylesheet" href="fancy.min.css"/>
<link rel="stylesheet" href="computer science 2 kim and kim.css"/>
<script src="compatibility.min.js"></script>
<script src="pdf2htmlEX.min.js"></script>
<script>
try{
  pdf2htmlEX.defaultViewer = new pdf2htmlEX.Viewer({});
}catch(e){}
</script>
<title></title>
</head>
<body>
<div id="sidebar">
<div id="outline">
</div>
</div>
<div id="page-container">
<div id="pf1" class="pf w0 h0" data-page-no="1"><div class="pc pc1 w0 h0"><img class="bi x0 y0 w1 h1" alt="" src="bg1.png"/><div class="t m0 x1 h2 y1 ff1 fs0 fc0 sc0 ls0 ws0"> AASRI <span class="_ _0"> </span>Procedia  <span class="_ _0"> </span> 5  <span class="_ _0"> </span>( 2013 ) <span class="_ _0"> </span> 2 <span class="_ _0"> </span>– <span class="_ _0"> </span>8 </div><div class="t m0 x2 h2 y2 ff1 fs0 fc0 sc0 ls0 ws1">2212-6716 © 2013 The Authors. Published by Elsevier B.V.</div><div class="t m0 x2 h2 y3 ff1 fs0 fc0 sc0 ls0 ws1">Selection and/or peer review under responsibility of American Applied Science Research Institute</div><div class="t m0 x2 h2 y4 ff1 fs0 fc0 sc0 ls0 ws0">doi: 10.1016/j.aasri.2013.10.051 </div><div class="t m0 x3 h3 y5 ff2 fs1 fc0 sc0 ls0 ws1">ScienceDir<span class="_ _1"></span>ect</div><div class="t m0 x4 h4 y6 ff3 fs0 fc0 sc0 ls0 ws1"> </div><div class="t m0 x5 h5 y7 ff3 fs2 fc0 sc0 ls1 ws1">2013 AASRI Conference on Parallel and Distributed Computing Systems </div><div class="t m0 x6 h6 y8 ff3 fs3 fc0 sc0 ls2 ws1">Parallel Processing of Sensor Network Data using Column-</div><div class="t m0 x7 h6 y9 ff3 fs3 fc0 sc0 ls2 ws2">Oriented Databases </div><div class="t m0 x8 h7 ya ff3 fs4 fc0 sc0 ls3 ws1">Kyung-Chang Kim</div><div class="t m0 x9 h8 yb ff3 fs5 fc0 sc0 ls0 ws1">a</div><div class="t m0 xa h7 ya ff3 fs4 fc0 sc0 ls2 ws1">*, Choung-Seok Kim</div><div class="t m0 xb h8 yb ff3 fs5 fc0 sc0 ls0 ws1">b</div><div class="t m0 xc h7 ya ff3 fs4 fc0 sc0 ls0 ws1"> </div><div class="t m0 xd h9 yc ff4 fs6 fc0 sc0 ls0 ws1">a</div><div class="t m0 xe h4 yd ff4 fs0 fc0 sc0 ls2 ws1">Dept. of  Computer Engineering, Hongik University, Seoul, Korea </div><div class="t m0 xe h9 ye ff4 fs6 fc0 sc0 ls0 ws1">b</div><div class="t m0 xf h4 yf ff4 fs0 fc0 sc0 ls3 ws1">Dept. of Information Technology, Silla University, Pusan, Korea  </div><div class="t m0 x10 h4 y10 ff3 fs0 fc0 sc0 ls0 ws1"> </div><div class="t m0 x4 ha y11 ff5 fs7 fc0 sc0 ls0 ws1">Abstract </div><div class="t m0 x4 hb y12 ff3 fs7 fc0 sc0 ls1 ws3">Many wireless sensor network (WSN) applications require join of sensor data belonging to v<span class="_ _1"></span>arious sensor nodes. For join </div><div class="t m0 x4 hb y13 ff3 fs7 fc0 sc0 ls2 ws4">processing, it is important <span class="_ _1"></span>to minimize the comm<span class="_ _1"></span>unication cost since it is the main consumer of battery power. In this </div><div class="t m0 x4 hb y14 ff3 fs7 fc0 sc0 ls0 ws3">paper, we introduce a parallel join techniqu<span class="_ _1"></span>e for sensor networks. A WSN consists of man<span class="_ _1"></span>y independent sensor nodes and </div><div class="t m0 x4 hb y15 ff3 fs7 fc0 sc0 ls1 ws5">provides a natural platform for a shared-nothing architecture to <span class="_ _1"></span>carry out parallel processing. The proposed parallel join </div><div class="t m0 x4 hb y16 ff3 fs7 fc0 sc0 ls2 ws6">algorithm is based on sensor data th<span class="_ _1"></span>at are stored in column-oriented d<span class="_ _1"></span>atabases. A column-oriented database store table </div><div class="t m0 x4 hb y17 ff3 fs7 fc0 sc0 ls2 ws4">data column-wise rather than ro<span class="_ _1"></span>w-wise as in traditional r<span class="_ _1"></span>elational databases. The proposed algorithm is <span class="_ _1"></span>energy-efficient </div><div class="t m0 x4 hb y18 ff3 fs7 fc0 sc0 ls2 ws7">for two clear reasons. First, unlike r<span class="_ _1"></span>elational databases, only relev<span class="_ _1"></span>ant columns are shipped <span class="_ _1"></span>to the join region<span class="_ _1"></span> for final join </div><div class="t m0 x4 hb y19 ff3 fs7 fc0 sc0 ls2 ws5">processing. Second, parallel join processing of sensor data also im<span class="_ _1"></span>proves performance. The perform<span class="_ _1"></span>ance analysis shows </div><div class="t m0 x4 hb y1a ff3 fs7 fc0 sc0 ls2 ws3">that the proposed algorithm outperforms join algorithms for sensor data <span class="_ _1"></span>that are based on relational databases<span class="_ _1"></span>. </div><div class="t m0 x4 hc y1b ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x4 hc y1c ff3 fs8 fc0 sc0 ls0 ws8">© 2013 Published by Elsevier B.V. <span class="_ _1"></span> </div><div class="t m0 x4 hc y1d ff3 fs8 fc0 sc0 ls0 ws3">Selection and/or peer review under responsibility <span class="_ _1"></span><span class="ws1">of American Applied S<span class="ws3">cience Research Institute </span></span></div><div class="t m0 x4 hc y1e ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x4 h4 y1f ff4 fs0 fc0 sc0 ls2 ws1">Keywords: <span class="ff3">Wireless sensor network; parallel join; column-oriented databases; shared-nothing architecture; communication cost<span class="_ _2"></span> </span></div><div class="t m0 x5 h4 y20 ff3 fs0 fc0 sc0 ls0 ws1"> </div><div class="t m0 x4 h4 y21 ff3 fs0 fc0 sc0 ls0 ws1"> </div><div class="t m0 x11 h4 y22 ff3 fs0 fc0 sc0 ls4 ws1">* Corresponding author. Tel.: +811-712-1606; fax: +82<span class="_ _1"></span>2-320-1606. </div><div class="t m0 x11 h4 y23 ff4 fs0 fc0 sc0 ls2 ws1">E-mail address:<span class="ff3 ls5"> kckim@hongik.ac.<span class="_ _1"></span>kr. </span></div><div class="t m0 x8 hd y24 ff6 fs7 fc0 sc0 ls0 ws1">A<span class="_ _1"></span>v<span class="_ _1"></span>ailable online at <span class="fc1">www<span class="_ _1"></span>.sciencedirect.com</span></div><div class="t m0 x4 hb y25 ff1 fs7 fc0 sc0 ls0 ws1">© 2013 The Authors. Published by Elsevier B.V.</div><div class="t m0 x4 hb y26 ff1 fs7 fc0 sc0 ls0 ws1">Selection and/or peer review under responsibility of American Applied Science Research Institute</div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf2" class="pf w0 h0" data-page-no="2"><div class="pc pc2 w0 h0"><img class="bi x12 y27 w2 he" alt="" src="bg2.png"/><div class="t m0 x13 h2 y28 ff1 fs0 fc0 sc0 ls0 ws1">3</div><div class="t m0 x14 h2 y28 ff7 fs0 fc0 sc0 ls0 ws1"> <span class="_ _3"></span>K<span class="_ _1"></span>yung-Chang Kim and Choung-Seok Kim <span class="_ _3"></span> /  <span class="_ _3"></span>AASRI Pr<span class="_ _1"></span>ocedia <span class="_ _3"></span>  <span class="_ _3"></span>5 <span class="_ _3"></span> ( <span class="_ _3"></span>2013 <span class="_ _3"></span>)  <span class="_ _3"></span>2 – 8 </div><div class="t m0 x4 h4 y29 ff3 fs0 fc0 sc0 ls0 ws1"> </div><div class="t m0 x4 hc y2a ff5 fs8 fc0 sc0 ls6 ws1">1.<span class="ff8 ls0"> <span class="ff5">Introd<span class="_ _2"></span>uctio<span class="_ _2"></span>n </span></span></div><div class="t m0 x11 hc y2b ff3 fs8 fc0 sc0 ls1 ws3">Many sensor network applications re<span class="_ _1"></span>quire correlation <span class="ls2">of se<span class="_ _1"></span>nsor readings scattered am<span class="_ _1"></span>ong sensor nodes. For </span></div><div class="t m0 x4 hc y2c ff3 fs8 fc0 sc0 ls0 ws9">example, in an object trac<span class="_ _1"></span>king system, one may be interes<span class="_ _1"></span>ted in objects that travelled from<span class="_ _1"></span> one designated </div><div class="t m0 x4 hc y2d ff3 fs8 fc0 sc0 ls0 ws5">region to another<span class="_ _1"></span> designated region <span class="ls1">to monitor t<span class="_ _1"></span>he traffic volum<span class="_ _1"></span>e and speed of pa<span class="_ _1"></span>rticular objects. The se<span class="_ _1"></span>nsor </span></div><div class="t m0 x4 hc y2e ff3 fs8 fc0 sc0 ls1 ws5">network can be modelled as <span class="_ _1"></span>a distributed database and <span class="_ _1"></span><span class="ls2">the sensor readin<span class="_ _1"></span>gs are collected and processe<span class="_ _1"></span>d using </span></div><div class="t m0 x4 hc y2f ff3 fs8 fc0 sc0 ls2 wsa">queries. To be<span class="_ _1"></span>tter handle the sensor readin<span class="_ _1"></span>gs, the sensor readings ca<span class="_ _1"></span>n be stored as data using a rela<span class="_ _1"></span>tional </div><div class="t m0 x4 hc y30 ff3 fs8 fc0 sc0 ls1 ws8">database. A joi<span class="_ _1"></span>n is an important operation in <span class="_ _1"></span><span class="ls2">finding the correlation of sens<span class="_ _1"></span>or readings.  </span></div><div class="t m0 x11 hc y31 ff3 fs8 fc0 sc0 ls1 wsa">One of the m<span class="_ _1"></span>ost important perform<span class="_ _1"></span>ance criteria in proces<span class="_ _1"></span><span class="ls0 ws9">sing a join operation for sensor networks is to </span></div><div class="t m0 x4 hc y32 ff3 fs8 fc0 sc0 ls0 wsb">minimize the total communication cost<span class="wsc">. A total communication cost is <span class="wsd">the total data transfer between </span></span></div><div class="t m0 x4 hc y33 ff3 fs8 fc0 sc0 ls1 wsa">neighboring sensor nodes. Minim<span class="_ _1"></span>izing the communication cost is im<span class="_ _1"></span>portant because each sensor node has<span class="_ _1"></span> </div><div class="t m0 x4 hc y34 ff3 fs8 fc0 sc0 ls2 ws3">limited battery po<span class="_ _1"></span>wer and data<span class="_ _1"></span> communication is<span class="_ _1"></span> the main c<span class="_ _1"></span>onsumer of<span class="_ _1"></span> battery energy. <span class="_ _1"></span>A naïve way<span class="_ _1"></span> to answer </div><div class="t m0 x4 hc y35 ff3 fs8 fc0 sc0 ls2 ws4">an ad-hoc join query f<span class="_ _1"></span>or an application, such as object tr<span class="_ _1"></span>acking, is to move the sens<span class="_ _1"></span>or readings back to t<span class="_ _1"></span>he </div><div class="t m0 x4 hc y36 ff3 fs8 fc0 sc0 ls0 ws7">base station, and perform<span class="_ _1"></span> the join at<span class="_ _1"></span> the base station. This approach may incur high comm<span class="_ _1"></span>unication cost since </div><div class="t m0 x4 hc y37 ff3 fs8 fc0 sc0 ls0 ws5">all sensor data have to be transmitted to the base station. A better approach is to perform<span class="_ _1"></span> the join within the </div><div class="t m0 x4 hc y38 ff3 fs8 fc0 sc0 ls0 wsb">sensor network. In this in-network<span class="_ _2"></span> approach, several sensor nodes co<span class="_ _2"></span>llaborate to perform the join, i.e.<span class="_ _2"></span> </div><div class="t m0 x4 hc y39 ff3 fs8 fc0 sc0 ls0 ws5">distributed join. Due to the resource <span class="_ _1"></span>constraint, no single sensor node can <span class="_ _1"></span><span class="ls2">perform the join. <span class="_ _1"></span>The result of the<span class="_ _1"></span> </span></div><div class="t m0 x4 hc y3a ff3 fs8 fc0 sc0 ls0 ws3">join is then transmitted to the base station.  </div><div class="t m0 x11 hc y3b ff3 fs8 fc0 sc0 ls2 wse">In this paper, we <span class="_ _1"></span>propose a novel join techni<span class="_ _1"></span>que for wireless sens<span class="_ _1"></span>or networks to minim<span class="_ _1"></span>ize the total </div><div class="t m0 x4 hc y3c ff3 fs8 fc0 sc0 ls1 wsf">communication cost a<span class="_ _1"></span>nd improve performance. O<span class="_ _1"></span>ur approa<span class="ls0 ws10">ch is based on two techniques; first,<span class="_ _1"></span> we use a </span></div><div class="t m0 x4 hc y3d ff3 fs8 fc0 sc0 ls0 ws5">column-oriented databases rath<span class="ws4">er than relational databases to st<span class="_ _1"></span>ore sensor data and second, we use a parallel </span></div><div class="t m0 x4 hc y3e ff3 fs8 fc0 sc0 ls0 ws3">join technique. Recent years<span class="_ _1"></span> have seen an increase<span class="_ _1"></span>d attention and researc<span class="_ _1"></span>h work on column-oriented <span class="_ _1"></span>databases. </div><div class="t m0 x4 hc y3f ff3 fs8 fc0 sc0 ls0 wsb">A column-oriented database store data in colum<span class="_ _1"></span>n order (i.e. column-wise) and not in row order as in </div><div class="t m0 x4 hc y40 ff3 fs8 fc0 sc0 ls0 ws7">traditional relational databases. T<span class="_ _1"></span>hey are more I/O efficient for <span class="_ _1"></span>read-only queries since they only access those </div><div class="t m0 x4 hc y41 ff3 fs8 fc0 sc0 ls0 ws11">columns (or attributes) required by the que<span class="_ _1"></span>ry. The read-only queries are co<span class="ws12">mmon in work<span class="ws13">loads and </span></span></div><div class="t m0 x4 hc y42 ff3 fs8 fc0 sc0 ls1 ws14">applications found in data a<span class="_ _1"></span>nalysis, semantic web <span class="ls2">an<span class="_ _1"></span>d sensor networks. Sinc<span class="_ _1"></span>e the sensor <span class="_ _1"></span>network can be </span></div><div class="t m0 x4 hc y43 ff3 fs8 fc0 sc0 ls1 ws5">modelled as a distributed dat<span class="_ _1"></span>abase and the sensor nodes<span class="_ _1"></span><span class="ls0"> are independent, it provides a <span class="_ _1"></span>natural platform for a </span></div><div class="t m0 x4 hc y44 ff3 fs8 fc0 sc0 ls1 wsf">shared-nothing architecture<span class="_ _1"></span>. Using the shared-n<span class="_ _1"></span>othing arch<span class="ls2">itecture, we can distribute<span class="_ _1"></span> the sensor data to be </span></div><div class="t m0 x4 hc y45 ff3 fs8 fc0 sc0 ls2 ws8">joined and perform<span class="_ _1"></span> parallel join to improve perform<span class="_ _1"></span>ance.  </div><div class="t m0 x11 hc y46 ff3 fs8 fc0 sc0 ls0 ws15">To test the efficiency of our proposed join techni<span class="ws16">que a perform<span class="_ _1"></span>ance analysis is conducted. Through </span></div><div class="t m0 x4 hc y1a ff3 fs8 fc0 sc0 ls2 ws11">performance experim<span class="_ _1"></span>ents, we show t<span class="_ _1"></span>hat our technique outperf<span class="_ _1"></span>orms current join algorithm<span class="_ _1"></span>s for sensor </div><div class="t m0 x4 hc y47 ff3 fs8 fc0 sc0 ls2 ws1">networks based on both relational databases and column-oriented data<span class="_ _1"></span>bases.  </div><div class="t m0 x11 hc y48 ff3 fs8 fc0 sc0 ls2 wsa">The rest of the pa<span class="_ _1"></span>per is organized as follows. We <span class="_ _1"></span>discuss related w<span class="_ _1"></span>orks in Section 2. In Section <span class="_ _1"></span>3, we </div><div class="t m0 x4 hc y26 ff3 fs8 fc0 sc0 ls2 ws3">present a novel<span class="_ _1"></span> join algorithm ba<span class="_ _1"></span>sed on column-oriented <span class="_ _1"></span>databases and parallelism<span class="_ _1"></span>. The query <span class="_ _1"></span>performance<span class="_ _1"></span> of </div><div class="t m0 x4 hc y49 ff3 fs8 fc0 sc0 ls0 wsf">the proposed algorithm is com<span class="_ _1"></span>pared with traditional join algorithms <span class="ls2">for sensor networ<span class="_ _1"></span>k in Section 4. The </span></div><div class="t m0 x4 hc y4a ff3 fs8 fc0 sc0 ls1 ws8">conclusion is given in Secti<span class="_ _1"></span>on 5.  </div><div class="t m0 x4 hc y4b ff5 fs8 fc0 sc0 ls6 ws1">2.<span class="ff8 ls0"> <span class="ff5">Related Works </span></span></div><div class="t m0 x11 hc y4c ff3 fs8 fc0 sc0 ls2 ws17">Several techniques to handle sim<span class="_ _1"></span>ple joins in sensor <span class="_ _1"></span>networks are propos<span class="_ _1"></span>ed in the literature [1,2]<span class="_ _1"></span>. The </div><div class="t m0 x4 hc y4d ff3 fs8 fc0 sc0 ls0 ws9">general join strategies in sensor netw<span class="ws18">orks can be classified as <span class="_ _1"></span>naïve jo<span class="ws9">in, sequential join, and centroid join </span></span></div><div class="t m0 x4 hc y4e ff3 fs8 fc0 sc0 ls0 ws5">depending on the location of the join region in the sensor <span class="_ _1"></span>network [2]. The main problem with these general </div><div class="t m0 x4 hc y4f ff3 fs8 fc0 sc0 ls0 wse">approaches is the communication cost overhead associated with low join selectivity. Tuples that are not </div><div class="t m0 x4 hc y50 ff3 fs8 fc0 sc0 ls0 ws1">candidates for join can be unnecessarily<span class="ws8"> transmitted to the join region.  </span></div><div class="t m0 x11 hc y51 ff3 fs8 fc0 sc0 ls0 ws5">A better approach is to transmit only those records that are involved in t<span class="_ _1"></span>he join to the join region. Several </div><div class="t m0 x4 hc y52 ff3 fs8 fc0 sc0 ls0 ws5">filtering techniques were proposed where only those sensor data involved in the join result are transmitted to </div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf3" class="pf w0 h0" data-page-no="3"><div class="pc pc3 w0 h0"><img class="bi x15 y27 w3 he" alt="" src="bg3.png"/><div class="t m0 x0 h2 y28 ff1 fs0 fc0 sc0 ls0 ws1">4<span class="ff7">  <span class="_ _4"> </span> <span class="_ _3"></span>K<span class="_ _1"></span>yung-Chang Kim and Choung-Seok Kim <span class="_ _3"></span> /  <span class="_ _3"></span>AASRI Pr<span class="_ _1"></span>ocedia <span class="_ _3"></span>  <span class="_ _3"></span>5 <span class="_ _3"></span> ( <span class="_ _3"></span>2013 <span class="_ _3"></span>)  <span class="_ _3"></span>2 – 8 </span></div><div class="t m0 x16 h4 y29 ff3 fs0 fc0 sc0 ls0 ws1"> </div><div class="t m0 x16 hc y2a ff3 fs8 fc0 sc0 ls0 ws7">the join region near the ba<span class="_ _2"></span>se station. One approach<span class="_ _2"></span> is the synopsis join (SNJ) algorithm [3]. Th<span class="_ _2"></span>e key idea is to </div><div class="t m0 x16 hc y53 ff3 fs8 fc0 sc0 ls0 ws7">use synopsis of sensor readings to prune those read<span class="_ _2"></span>ings that are irrelevant to jo<span class="_ _2"></span>in results. Another technique is </div><div class="t m0 x16 hc y2b ff3 fs8 fc0 sc0 ls0 ws5">the record filtering using bit-vector (RFB) algorithm [4]. <span class="ws4">The RFB algorithm uses bit <span class="_ _1"></span>vectors produced after </span></div><div class="t m0 x16 hc y2c ff3 fs8 fc0 sc0 ls1 ws8">semi-join is performed to <span class="_ _1"></span>prune unnecessary data <span class="_ _1"></span>before shipping data from<span class="_ _1"></span> each node to the <span class="_ _1"></span>join region.  </div><div class="t m0 x17 hc y2d ff3 fs8 fc0 sc0 ls0 wse">Important optimization techniques exist for colum<span class="_ _1"></span>n-oriented databases. Materialization strategies, both </div><div class="t m0 x16 hc y2e ff3 fs8 fc0 sc0 ls0 ws5">early and late, are important during query reconstruction [5]. Th<span class="_ _2"></span>e invisible join [6] ex<span class="_ _2"></span>tends previou<span class="_ _2"></span>s work on </div><div class="t m0 x16 hc y2f ff3 fs8 fc0 sc0 ls2 ws9">improving star schem<span class="_ _1"></span>a queries using a colum<span class="_ _1"></span>n-oriented layout. <span class="_ _1"></span>A join algorithm based on colum<span class="_ _1"></span>n-oriented </div><div class="t m0 x16 hc y30 ff3 fs8 fc0 sc0 ls2 ws4">database was proposed to perform join processing of da<span class="ls0 ws9">ta in sensor networks [7]. The algorithm, which we </span></div><div class="t m0 x16 hc y31 ff3 fs8 fc0 sc0 ls0 ws3">refer to as EM, is based on an early material<span class="_ _1"></span><span class="ws8">ized strategy in column-oriente<span class="_ _1"></span>d database.  </span></div><div class="t m0 x16 hc y33 ff5 fs8 fc0 sc0 ls6 ws1">3.<span class="ff8 ls0"> <span class="ff5 ws3">The Proposed Algorithm  </span></span></div><div class="t m0 x17 hc y35 ff3 fs8 fc0 sc0 ls0 ws5">Consider a sensor network co<span class="_ _1"></span>vering a road network. Each sensor node detects ids’ of vehicles, record the </div><div class="t m0 x16 hc y36 ff3 fs8 fc0 sc0 ls2 ws5">timestamp at whic<span class="_ _1"></span>h vehicles were detected<span class="_ _1"></span>, and keep <span class="ls0">the time-stamped records fo<span class="ls1">r a fixed durati<span class="_ _1"></span>on. Suppose </span></span></div><div class="t m0 x16 hc y37 ff3 fs8 fc0 sc0 ls2 wsa">that region R and re<span class="_ _1"></span>gion S represent two sets of sens<span class="_ _1"></span>or nodes where <span class="_ _1"></span>vehicle detection takes place. A join </div><div class="t m0 x16 hc y38 ff3 fs8 fc0 sc0 ls0 ws4">query to determine speeds of ve<span class="_ _1"></span>hicles travelling between the two regions is as follows: <span class="ff4 ws9">Select R.ve<span class="_ _1"></span>hicle_id, </span></div><div class="t m0 x16 hc y39 ff4 fs8 fc0 sc0 ls0 ws5">R.time, S.time From R, S Where R.l<span class="_ _1"></span>oc in R_region AND <span class="ls2">S.loc<span class="_ _1"></span> in S_region AND R.vehicle_id = S.vehicle_id.<span class="_ _1"></span>. </span></div><div class="t m0 x16 hc y3a ff3 fs8 fc0 sc0 ls2 ws15">To evaluate the above que<span class="_ _1"></span>ry, sensor rea<span class="_ _1"></span>dings from<span class="_ _1"></span> region R and region S<span class="_ _1"></span> are collected and joined <span class="_ _1"></span>on </div><div class="t m0 x16 hc y3b ff3 fs8 fc0 sc0 ls1 ws8">vehicle_id attribute. The exa<span class="_ _1"></span>mple <span class="ls0 ws1">join query is <span class="ws3">taken from [3].  </span></span></div><div class="t m0 x17 hc y3c ff3 fs8 fc0 sc0 ls2 wse">In this paper,<span class="_ _1"></span> we assume that the sens<span class="_ _1"></span>or data are <span class="ls1">stored in a col<span class="_ _1"></span>umn-oriented database rather than a<span class="_ _1"></span> </span></div><div class="t m0 x16 hc y3d ff3 fs8 fc0 sc0 ls0 ws5">relational database. Column-oriented databases store data<span class="_ _1"></span><span class="ls1"> column-wise (in colum<span class="_ _1"></span>ns) <span class="ls0">rather than row-wise (in </span></span></div><div class="t m0 x16 hc y3e ff3 fs8 fc0 sc0 ls0 ws3">rows) as in relational databases. Column-ori<span class="_ _1"></span>ented databases are more efficient for read-only queries since they<span class="_ _1"></span> </div><div class="t m0 x16 hc y3f ff3 fs8 fc0 sc0 ls0 ws15">read from disk only those attributes <span class="_ _1"></span>(or columns) accessed by t<span class="_ _1"></span>he query. There are two materialization </div><div class="t m0 x16 hc y40 ff3 fs8 fc0 sc0 ls0 ws7">strategies, early and late, in column-oriented databases. M<span class="_ _1"></span>aterialization, also known as tuple stitching or t<span class="_ _1"></span>uple </div><div class="t m0 x16 hc y41 ff3 fs8 fc0 sc0 ls2 ws4">construction, is a process of com<span class="_ _1"></span>bining single-colum<span class="_ _1"></span>n projections<span class="_ _1"></span> into wider tuples and is needed t<span class="_ _1"></span>o output </div><div class="t m0 x16 hc y42 ff3 fs8 fc0 sc0 ls0 wsa">row-style tuples to support standards-compliant rela<span class="_ _2"></span>tional database interface such as ODBC an<span class="_ _2"></span>d JDBC. In </div><div class="t m0 x16 hc y43 ff3 fs8 fc0 sc0 ls2 wsf">early materialization strategy, each colum<span class="_ _1"></span>n is added to t<span class="_ _1"></span>he intermediate query result to form<span class="_ _1"></span> tuples if the </div><div class="t m0 x16 hc y44 ff3 fs8 fc0 sc0 ls0 ws4">column is needed. In late materialization strategy, the accessed col<span class="_ _1"></span>umns do not form tuples until after som<span class="_ _1"></span>e </div><div class="t m0 x16 hc y45 ff3 fs8 fc0 sc0 ls2 ws1">part of the query plan has been processed.  </div><div class="t m0 x17 hc y46 ff3 fs8 fc0 sc0 ls0 ws5">A general query we consider in<span class="ws4"> our paper is as follows:  <span class="ff4 ls2 ws19">SELECT R.A1, R.A2, S.A2 FROM R<span class="_ _1"></span>, S WHERE </span></span></div><div class="t m0 x16 hc y1a ff4 fs8 fc0 sc0 ls2 ws8">R.loc in R-region AND S.l<span class="_ _1"></span>oc in S-region AN<span class="_ _1"></span>D R.A1 = S.A1. <span class="_ _1"></span><span class="ff3 ls0">R and S are correlation tables and t<span class="_ _1"></span>he R-region (S-</span></div><div class="t m0 x16 hc y47 ff3 fs8 fc0 sc0 ls2 ws5">region) is the R regi<span class="_ _1"></span>on (S region) i<span class="_ _1"></span>n the sensor networ<span class="_ _1"></span>k where sensor <span class="_ _1"></span>readings are taken. R.A1 and <span class="_ _1"></span>S.A1 are </div><div class="t m0 x16 hc y48 ff3 fs8 fc0 sc0 ls0 ws3">join attributes in R and S respectively. A query is initiated at the sensor node called query sink (i.e. sink <span class="_ _1"></span>node) </div><div class="t m0 x16 hc y26 ff3 fs8 fc0 sc0 ls0 ws4">and the query result is also collected at query sink. Si<span class="_ _1"></span>nce the memory size at each node is lim<span class="_ _1"></span>ited, the sink </div><div class="t m0 x16 hc y49 ff3 fs8 fc0 sc0 ls0 ws5">node is unable to perform the join lo<span class="ls1">cally. The join has to be perform<span class="_ _1"></span>ed <span class="ls0">through the collaboration of several </span></span></div><div class="t m0 x16 hc y4a ff3 fs8 fc0 sc0 ls0 ws8">nodes called the <span class="ff9 ws3">join region</span><span class="ws1">. </span></div><div class="t m0 x17 hc y54 ff3 fs8 fc0 sc0 ls2 ws3">The proposed <span class="_ _1"></span>algorithm is a distributed algorithm<span class="_ _1"></span> invol<span class="_ _1"></span><span class="ls3">ving the R region, S-re<span class="_ _1"></span>gion, join region a<span class="_ _1"></span>nd the sink </span></div><div class="t m0 x16 hc y4b ff3 fs8 fc0 sc0 ls1 ws5">node. The R (S) region contains a num<span class="_ _1"></span>ber of sensor nodes, each storing a part of relation R (S). <span class="_ _1"></span>In addition, </div><div class="t m0 x16 hc y55 ff3 fs8 fc0 sc0 ls2 wsf">the join regi<span class="_ _1"></span>on F also contains several <span class="_ _1"></span>sensor nodes <span class="ls0">that collaborate to perform<span class="_ _1"></span> distributed join. The join </span></div><div class="t m0 x16 hc y4c ff3 fs8 fc0 sc0 ls0 ws4">algorithm, a late materialized strategy, executes in three phases, nam<span class="_ _1"></span>ely the <span class="ff9 ws1">selection</span> phase, the <span class="ff9 ws1">join<span class="_ _2"></span></span><span class="ls4"> phase, </span></div><div class="t m0 x16 hc y4d ff3 fs8 fc0 sc0 ls0 ws3">and the <span class="ff9 ws1">result</span> phase. In the selection phase, the join colu<span class="_ _2"></span>mn values are sent to the join reg<span class="_ _2"></span>ion F initially. In the </div><div class="t m0 x16 hc y4e ff3 fs8 fc0 sc0 ls3 ws3">join phase, a se<span class="_ _1"></span>mi-join is perform<span class="_ _1"></span>ed between the joi<span class="_ _1"></span>n columns of R and <span class="_ _1"></span>S to ship only qualifie<span class="_ _1"></span>d column values </div><div class="t m0 x16 hc y4f ff3 fs8 fc0 sc0 ls2 ws7">from R region and <span class="_ _1"></span>S region to the joi<span class="_ _1"></span>n node F. In the result phase<span class="_ _1"></span>, the qualified column values of R a<span class="_ _1"></span>nd S are </div><div class="t m0 x16 hc y50 ff3 fs8 fc0 sc0 ls0 ws3">stitched together to construct tuples<span class="ws8"> and shipped to the si<span class="_ _1"></span>nk node.  </span></div><div class="t m0 x17 hc y51 ff3 fs8 fc0 sc0 ls0 ws9">The selection phase of the proposed algorithm is composed of two steps. In the first step, the sink node </div><div class="t m0 x16 hc y52 ff3 fs8 fc0 sc0 ls0 ws3">initiates the query and sends it a node i<span class="_ _1"></span>n R region and S <span class="_ _1"></span>region. The receiving <span class="_ _1"></span>node broadcasts t<span class="_ _1"></span>he query to the </div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf4" class="pf w0 h0" data-page-no="4"><div class="pc pc4 w0 h0"><img class="bi x12 y27 w2 he" alt="" src="bg4.png"/><div class="t m0 x13 h2 y28 ff1 fs0 fc0 sc0 ls0 ws1">5</div><div class="t m0 x14 h2 y28 ff7 fs0 fc0 sc0 ls0 ws1"> <span class="_ _3"></span>K<span class="_ _1"></span>yung-Chang Kim and Choung-Seok Kim <span class="_ _3"></span> /  <span class="_ _3"></span>AASRI Pr<span class="_ _1"></span>ocedia <span class="_ _3"></span>  <span class="_ _3"></span>5 <span class="_ _3"></span> ( <span class="_ _3"></span>2013 <span class="_ _3"></span>)  <span class="_ _3"></span>2 – 8 </div><div class="t m0 x4 h4 y29 ff3 fs0 fc0 sc0 ls0 ws1"> </div><div class="t m0 x4 hc y2a ff3 fs8 fc0 sc0 ls2 ws19">other nodes in R (S) region. <span class="_ _1"></span>Both relation R and S are partitioned i<span class="_ _1"></span>nto a number of <span class="_ _1"></span>disjoint sub-tables, each </div><div class="t m0 x4 hc y53 ff3 fs8 fc0 sc0 ls2 wsf">with join attribute value ra<span class="_ _1"></span>nge. Each node in R (S<span class="_ _1"></span>) <span class="wsa">region <span class="_ _1"></span>stores a sub-table. I<span class="_ _1"></span>n the second step, the joi<span class="_ _1"></span>n </span></div><div class="t m0 x4 hc y2b ff3 fs8 fc0 sc0 ls0 ws4">column values of <span class="_ _1"></span>relations R and S are shi<span class="_ _1"></span>pped to th<span class="ls2">e join <span class="_ _1"></span>node F. Using a <span class="_ _1"></span>hash-based distribution schem<span class="_ _1"></span>e, </span></div><div class="t m0 x4 hc y2c ff3 fs8 fc0 sc0 ls0 ws5">each node in F join two subs<span class="_ _1"></span>ets of R and S with same join value <span class="_ _1"></span>range. Same join attribute value <span class="_ _1"></span>of R and S </div><div class="t m0 x4 hc y2d ff3 fs8 fc0 sc0 ls0 ws3">always joined at the same node in F.  </div><div class="t m0 x11 hc y2e ff3 fs8 fc0 sc0 ls2 ws17">The join phase of the propose<span class="_ _1"></span>d algorithm is composed of t<span class="_ _1"></span>hree steps. In the first<span class="_ _1"></span> step, a semi-join i<span class="_ _1"></span>s </div><div class="t m0 x4 hc y2f ff3 fs8 fc0 sc0 ls0 ws4">performed at each node. The <span class="_ _1"></span>result of the join produces two data structures. One is t<span class="_ _1"></span>he <span class="ff5 ls2">position list</span> and the </div><div class="t m0 x4 hc y30 ff3 fs8 fc0 sc0 ls2 ws5">other is the <span class="ff5 ls0 ws1">bitmap<span class="_ _1"></span><span class="ff3 ws19"> (for R and S). We assume that a metadata is <span class="_ _1"></span><span class="ws5">present to calculate the correct position list </span></span></span></div><div class="t m0 x4 hc y31 ff3 fs8 fc0 sc0 ls0 ws4">and bitmap in a distributed case. The result of the semi-join is a position list with two columns, one for the </div><div class="t m0 x4 hc y32 ff3 fs8 fc0 sc0 ls0 wsa">join column of R and th<span class="_ _2"></span>e other for the join co<span class="_ _2"></span>lumn of S. Each entry pair in the position<span class="_ _2"></span> list contains the </div><div class="t m0 x4 hc y33 ff3 fs8 fc0 sc0 ls0 ws4">positions of join co<span class="_ _2"></span>lumn of R and S with the same join attribute value. The bitmap contain<span class="_ _2"></span>s the positions of </div><div class="t m0 x4 hc y34 ff3 fs8 fc0 sc0 ls0 ws1a">the join column that satisfies the join condition. In t<span class="_ _1"></span>he second step, the bitmap is sent back to a node in R (S) </div><div class="t m0 x4 hc y35 ff3 fs8 fc0 sc0 ls1 ws5">region. The re<span class="_ _1"></span>ceiving node broadcast the <span class="_ _1"></span>bitmap to t<span class="_ _1"></span>he other nodes i<span class="_ _1"></span>n R (S) region. In the thi<span class="_ _1"></span>rd step, at each </div><div class="t m0 x4 hc y36 ff3 fs8 fc0 sc0 ls0 ws7">node, the bit<span class="_ _2"></span>map is used to extract values from qu<span class="_ _2"></span>alified columns at the correspond<span class="_ _2"></span>ing positions where th<span class="_ _2"></span>e bit </div><div class="t m0 x4 hc y37 ff3 fs8 fc0 sc0 ls0 ws3">is set to 1. The selected column values are shipped to the designated <span class="_ _1"></span>node in the join region F. We assume that </div><div class="t m0 x4 hc y38 ff3 fs8 fc0 sc0 ls0 ws5">a metadata is present to map the table <span class="_ _1"></span>bitmap to sub-<span class="ls2">tables<span class="_ _1"></span>. The hash-based sc<span class="_ _1"></span>heme in the second ste<span class="_ _1"></span>p of the </span></div><div class="t m0 x4 hc y39 ff3 fs8 fc0 sc0 ls0 ws7">selection phase is used<span class="_ _2"></span> to ship the selected column valu<span class="_ _2"></span>es to the same node in F region<span class="_ _2"></span> as the join values with </div><div class="t m0 x4 hc y3a ff3 fs8 fc0 sc0 ls0 ws8">the same position. </div><div class="t m0 x11 hc y3b ff3 fs8 fc0 sc0 ls0 ws3">The result phase of the proposed algorithm is <span class="ls1">composed <span class="_ _1"></span>of two steps. In th<span class="_ _1"></span>e first step, at each node in F, the </span></div><div class="t m0 x4 hc y3c ff3 fs8 fc0 sc0 ls0 ws1b">position list and the bitmap in the first step of the jo<span class="_ _2"></span>in phase is used to stitch together the column values of R </div><div class="t m0 x4 hc y3d ff3 fs8 fc0 sc0 ls0 ws9">and S to construct tuples. The tuple stitching is perform<span class="_ _1"></span>ed in parallel at each node in F. <span class="_ _1"></span>We assume that a </div><div class="t m0 x4 hc y3e ff3 fs8 fc0 sc0 ls0 ws3">metadata is present to map column values of R and S gi<span class="_ _1"></span>ven the position list and bitm<span class="_ _1"></span>ap. In the second step, the </div><div class="t m0 x4 hc y3f ff3 fs8 fc0 sc0 ls1 ws8">constructed tuples from each node<span class="_ _1"></span> in F are shi<span class="_ _1"></span>pped to the sink node a<span class="_ _1"></span>s the query result.  </div><div class="t m0 x11 hc y40 ff3 fs8 fc0 sc0 ls1 ws5">Since the sensor <span class="_ _1"></span>nodes in the sensor net<span class="_ _1"></span>work are inde<span class="ls0">pendent, it <span class="_ _1"></span>provides a natural platf<span class="_ _1"></span>orm for a shared-</span></div><div class="t m0 x4 hc y41 ff3 fs8 fc0 sc0 ls0 ws4">nothing architecture to per<span class="_ _1"></span>form parallel processing. It<span class="_ _1"></span> is straightforward to c<span class="_ _1"></span>onvert the distributed algorithm<span class="_ _1"></span> </div><div class="t m0 x4 hc y42 ff3 fs8 fc0 sc0 ls2 ws5">just described to a pa<span class="_ _1"></span>rallel algorithm if we assum<span class="_ _1"></span>e <span class="ls1">a shared-nothing architecture for the<span class="_ _1"></span> sensor network. The </span></div><div class="t m0 x4 hc y43 ff3 fs8 fc0 sc0 ls0 ws3">hash-based distribution sche<span class="_ _1"></span>me ensures that tuples with sa<span class="_ _1"></span>me join attribute value are al<span class="_ _1"></span>ways sent and joi<span class="_ _1"></span>ned at </div><div class="t m0 x4 hc y44 ff3 fs8 fc0 sc0 ls0 ws1c">the same join node. This ensures that both join and tuple stitch<span class="ws1d">ing can <span class="_ _1"></span>be performed in parallel at each </span></div><div class="t m0 x4 hc y45 ff3 fs8 fc0 sc0 ls0 ws3">designated node. </div><div class="t m0 x4 hc y1a ff5 fs8 fc0 sc0 ls6 ws1">4.<span class="ff8 ls0"> <span class="ff5">Performance Analysis </span></span></div><div class="t m0 x11 hc y48 ff3 fs8 fc0 sc0 ls1 ws5">To test the cost-effectiveness <span class="_ _1"></span>of the join algorithm<span class="_ _1"></span> propos<span class="ls2">ed in this pape<span class="_ _1"></span>r, a performance analysis is m<span class="_ _1"></span>ade </span></div><div class="t m0 x4 hc y26 ff3 fs8 fc0 sc0 ls0 ws3">with the existing SNJ, RFB and EM al<span class="ls1">gorithms. SNJ a<span class="_ _1"></span>nd the RFB algorithm<span class="_ _1"></span>s are based on relational<span class="_ _1"></span> databases </span></div><div class="t m0 x4 hc y49 ff3 fs8 fc0 sc0 ls0 wsb">while the EM algorithm uses early m<span class="_ _1"></span>aterialization strategy <span class="ls2">in column-oriented data</span>bases. The different </div><div class="t m0 x4 hc y4a ff3 fs8 fc0 sc0 ls0 ws9">algorithms were compare<span class="_ _1"></span>d in terms of the communication cost <span class="_ _1"></span>which is the number of bytes transmitted to<span class="_ _1"></span> </div><div class="t m0 x4 hc y54 ff3 fs8 fc0 sc0 ls0 ws8">various nodes to get the join result. <span class="_ _1"></span> </div><div class="t m0 x4 hc y55 ff4 fs8 fc0 sc0 ls6 ws1">4.1<span class="ffa ls0"> <span class="_ _5"> </span><span class="ff4 ws8">Experiment Environment </span></span></div><div class="t m0 x11 hc y4d ff3 fs8 fc0 sc0 ls0 ws5">The join algorithms were c<span class="_ _1"></span>ompared for differe<span class="_ _1"></span>nt table sizes (2,000 tuples and 5,000 tuples) of R and S to </div><div class="t m0 x4 hc y4e ff3 fs8 fc0 sc0 ls0 ws1e">determine the effect of the increase i<span class="_ _1"></span>n the number <span class="ws1f">of tuples in tables R and S with regards to the </span></div><div class="t m0 x4 hc y4f ff3 fs8 fc0 sc0 ls1 ws5">communication cost. <span class="_ _1"></span>We also tested th<span class="ls2">e communication c<span class="_ _1"></span>ost of the diffe<span class="_ _1"></span>rent join algorithm<span class="_ _1"></span>s for several joi<span class="_ _1"></span>n </span></div><div class="t m0 x4 hc y50 ff3 fs8 fc0 sc0 ls0 ws5">selectivity (0.01, 0.05, 0.1, 0.5). Join selectivity is the fraction of the tuples in<span class="_ _1"></span> the table that satisfies the join </div><div class="t m0 x4 hc y51 ff3 fs8 fc0 sc0 ls0 ws8">condition. Join selectivity 0.05 means that only 5% of the tuples qualify t<span class="_ _1"></span>he query.  </div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf5" class="pf w0 h0" data-page-no="5"><div class="pc pc5 w0 h0"><img class="bi x15 y27 w3 he" alt="" src="bg5.png"/><div class="t m0 x0 h2 y28 ff1 fs0 fc0 sc0 ls0 ws1">6<span class="ff7">  <span class="_ _4"> </span> <span class="_ _3"></span>K<span class="_ _1"></span>yung-Chang Kim and Choung-Seok Kim <span class="_ _3"></span> /  <span class="_ _3"></span>AASRI Pr<span class="_ _1"></span>ocedia <span class="_ _3"></span>  <span class="_ _3"></span>5 <span class="_ _3"></span> ( <span class="_ _3"></span>2013 <span class="_ _3"></span>)  <span class="_ _3"></span>2 – 8 </span></div><div class="t m0 x16 h4 y29 ff3 fs0 fc0 sc0 ls0 ws1"> </div><div class="t m0 x17 hc y2a ff3 fs8 fc0 sc0 ls2 ws11">In order to sim<span class="_ _1"></span>plify network traffic analysis, we assumed that no <span class="_ _1"></span>failure occurs during message<span class="_ _1"></span> </div><div class="t m0 x16 hc y53 ff3 fs8 fc0 sc0 ls0 ws3">transmission. The size <span class="_ _1"></span>of the message a<span class="_ _1"></span>nd the tuple was<span class="_ _1"></span> assumed to be <span class="_ _1"></span>40 bytes each. For the given <span class="_ _1"></span>query, the </div><div class="t m0 x16 hc y2b ff3 fs8 fc0 sc0 ls0 ws5">size of the resulting join tuple (i.e. query result) was assumed to be 30 bytes. For column-oriented database, </div><div class="t m0 x16 hc y2c ff3 fs8 fc0 sc0 ls2 ws8">the size of each c<span class="_ _1"></span>olumn was assum<span class="_ _1"></span>ed to be 10 bytes.  </div><div class="t m0 x16 hc y2e ff4 fs8 fc0 sc0 ls6 ws1">4.2<span class="ffa ls0"> <span class="_ _5"> </span><span class="ff4 ws8">Experiment Result </span></span></div><div class="t m0 x17 hc y30 ff3 fs8 fc0 sc0 ls2 ws3">In executing a que<span class="_ _1"></span>ry, the total communication cost is the sum of the com<span class="_ _1"></span>munication costs for t<span class="_ _1"></span>he selection </div><div class="t m0 x16 hc y31 ff3 fs8 fc0 sc0 ls0 ws7">phase, join phase and t<span class="_ _1"></span>he result phase. The comm<span class="_ _1"></span>unication cost for each phase is t<span class="_ _1"></span>he cost of shipping data to </div><div class="t m0 x16 hc y32 ff3 fs8 fc0 sc0 ls2 ws4">other nodes for that pha<span class="_ _1"></span>se. The unit of comm<span class="_ _1"></span>unication cost is the <span class="_ _1"></span>number bytes transf<span class="_ _1"></span>erred from a node<span class="_ _1"></span> to </div><div class="t m0 x16 hc y33 ff3 fs8 fc0 sc0 ls2 wsa">other nodes. F<span class="_ _1"></span>ig. 1 shows the com<span class="_ _1"></span>muni<span class="ls0">cation cost of t<span class="_ _1"></span>he join algorithms<span class="ls1"> for <span class="_ _1"></span>different join selectivity and </span></span></div><div class="t m0 x16 hc y34 ff3 fs8 fc0 sc0 ls0 ws7">when the cardinality of table R and tab<span class="ws3">le S are 2000 tuples and 5,000 tu<span class="_ _1"></span><span class="ws7">ples respectively. Th<span class="ws3">e join selectivity </span></span></span></div><div class="t m0 x16 hc y35 ff3 fs8 fc0 sc0 ls2 wsa">used in the experiment ranges from<span class="_ _1"></span> <span class="ls0">0.01, 0.05, 0.1 to 0.5. Join selectivity of 0.1 means that<span class="_ _1"></span> only 10% of </span></div><div class="t m0 x16 hc y36 ff3 fs8 fc0 sc0 ls0 ws5">tuples satisfies the join condition. The size of the bitmap in our proposed algorithm is number of <span class="_ _1"></span>bits where </div><div class="t m0 x16 hc y37 ff3 fs8 fc0 sc0 ls0 ws4">each bit corresponds to a col<span class="_ _1"></span>umn position. Experiments show that t<span class="_ _1"></span>he proposed algorithm outperforms both </div><div class="t m0 x16 hc y38 ff3 fs8 fc0 sc0 ls0 ws7">the SNJ and the RFB algorithms for all different join selectivity tested. It also outperform<span class="_ _1"></span>s the EM algorithm </div><div class="t m0 x16 hc y39 ff3 fs8 fc0 sc0 ls2 ws8">which is also based on column-oriented databases. <span class="_ _1"></span><span class="ws2">As can be seen, the <span class="_ _1"></span>performance of the propose<span class="_ _1"></span>d algorithm </span></div><div class="t m0 x16 hc y3a ff3 fs8 fc0 sc0 ls0 ws5">gets better as the join selectivity gets lower. In othe<span class="_ _1"></span>r words, as m<span class="_ _1"></span>ore tuples are joined and output in the join </div><div class="t m0 x16 hc y3b ff3 fs8 fc0 sc0 ls0 ws3">result, the communication cost of the proposed algorithm further decreases. </div><div class="t m0 x18 hc y56 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x19 hc y57 ff5 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y58 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y59 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y5a ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y5b ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y5c ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y5d ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y5e ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y5f ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y60 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y61 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y62 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y63 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y64 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y65 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y66 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x1a hc y67 ff3 fs8 fc0 sc0 ls0 ws1"> </div><div class="t m0 x16 h4 y68 ff3 fs0 fc0 sc0 ls4 ws1">Fig. 1. Communication Cost on Join Selectivity </div><div class="t m0 x17 hc y69 ff3 fs8 fc0 sc0 ls0 ws5">Fig. 1 shows the communication<span class="_ _2"></span> cost of the different algorithms for different cardinalities of th<span class="_ _2"></span>e tables to </div><div class="t m0 x16 hc y6a ff3 fs8 fc0 sc0 ls0 ws3">be joined. The joi<span class="_ _1"></span>n selectivity used is 0.1 and the cardi<span class="_ _1"></span>nalities are varied from<span class="_ _1"></span> 2000 tuples each for R and S to </div><div class="t m0 x16 hc y6b ff3 fs8 fc0 sc0 ls0 ws20">5000 tuples each and 8000 tuple each. Our propo<span class="_ _2"></span>sed algorithm outperforms both the SNJ and the RFB </div><div class="t m0 x16 hc y6c ff3 fs8 fc0 sc0 ls0 ws17">algorithms for all different cardinalities tested. Compared to the SNJ <span class="_ _1"></span>algorithm, the communication cost </div><div class="t m0 x16 hc y6d ff3 fs8 fc0 sc0 ls0 ws1e">decreases around 18% for all cardinalities. Compared to the RFB algorithm<span class="_ _1"></span>, the communication cost </div><div class="t m0 x16 hc y6e ff3 fs8 fc0 sc0 ls0 wsa">decreases around 13% for all cardinalities. As can <span class="_ _1"></span>be seen, the performance of our proposed al<span class="_ _1"></span>gorithm is </div><div class="t m0 x16 hc y6f ff3 fs8 fc0 sc0 ls0 ws7">better but the communication cost remains the sam<span class="_ _1"></span>e for different cardinalities. The performance result shows </div><div class="t m0 x16 hc y70 ff3 fs8 fc0 sc0 ls0 ws3">that the join selectivity determines the communication cost <span class="_ _1"></span><span class="ws8">more than the size of <span class="ws3">the tables to <span class="ws1">be joined. </span></span></span></div><div class="t m1 x1b ha y71 ffb fs7 fc0 sc0 ls0 ws1">0</div><div class="t m1 x1c ha y72 ffb fs7 fc0 sc0 ls7 ws1">50</div><div class="t m1 x1d ha y73 ffb fs7 fc0 sc0 ls7 ws1">100</div><div class="t m1 x1d ha y74 ffb fs7 fc0 sc0 ls7 ws1">150</div><div class="t m1 x1d ha y75 ffb fs7 fc0 sc0 ls7 ws1">200</div><div class="t m1 x1d ha y76 ffb fs7 fc0 sc0 ls7 ws1">250</div><div class="t m1 x1d ha y77 ffb fs7 fc0 sc0 ls7 ws1">300</div><div class="t m1 x1d ha y78 ffb fs7 fc0 sc0 ls7 ws1">350</div><div class="t m1 x1d ha y79 ffb fs7 fc0 sc0 ls7 ws1">400</div><div class="t m1 x1d ha y7a ffb fs7 fc0 sc0 ls7 ws1">450</div><div class="t m1 x14 ha y7b ffb fs7 fc0 sc0 ls7 ws1">0.<span class="_ _1"></span>01<span class="_ _6"> </span>0.<span class="_ _1"></span>05<span class="_ _7"> </span>0.<span class="_ _1"></span>1<span class="_ _8"> </span>0.<span class="_ _1"></span>5<span class="_ _9"> </span>0.<span class="_ _1"></span>01<span class="_ _6"> </span>0.<span class="_ _1"></span>05<span class="_ _7"> </span>0.<span class="_ _1"></span>1<span class="_ _8"> </span>0.<span class="_ _1"></span>5</div><div class="t m2 x1e hc y73 ffc fs8 fc0 sc0 ls8 ws1">D<span class="_ _1"></span>a<span class="_ _a"></span>ta<span class="_ _b"> </span>T<span class="_ _a"></span>ra<span class="_ _1"></span>n<span class="_ _1"></span>s<span class="_ _a"></span>f<span class="_ _1"></span>er<span class="_ _c"> </span>(<span class="_ _1"></span>K<span class="_ _1"></span>B<span class="_ _a"></span>y<span class="_ _1"></span>tes<span class="_ _1"></span>)</div><div class="t m1 x1f hb y7c ffc fs7 fc0 sc0 ls8 ws1">J<span class="_ _1"></span>o<span class="_ _1"></span>i<span class="_ _a"></span>n<span class="_ _b"> </span>Sel<span class="_ _1"></span>e<span class="_ _1"></span>c<span class="_ _a"></span>t i<span class="_ _1"></span>v<span class="_ _a"></span>ity<span class="_ _0"> </span>(Lef<span class="_ _a"></span>t :<span class="_ _d"> </span>2000<span class="_ _d"> </span>tu<span class="_ _1"></span>pl<span class="_ _a"></span>es<span class="_ _1"></span>,<span class="_ _0"> </span>R<span class="_ _1"></span>i<span class="_ _1"></span>g<span class="_ _a"></span>ht:<span class="_ _0"> </span>5000<span class="_ _d"> </span>tu<span class="_ _1"></span>p<span class="_ _1"></span>l<span class="_ _1"></span>es<span class="_ _a"></span>)</div><div class="t m1 x20 ha y7d ffb fs7 fc0 sc0 ls2 ws1">SN<span class="_ _2"></span>J</div><div class="t m1 x20 ha y7e ffb fs7 fc0 sc0 ls0 ws1">RFB</div><div class="t m1 x20 ha y74 ffb fs7 fc0 sc0 ls9 ws1">EM</div><div class="t m1 x20 ha y7f ffb fs7 fc0 sc0 ls7 ws1">Propo<span class="_ _1"></span>se<span class="_ _a"></span>d</div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf6" class="pf w0 h0" data-page-no="6"><div class="pc pc6 w0 h0"><img class="bi x21 y27 w4 he" alt="" src="bg6.png"/><div class="t m0 x13 h2 y28 ff1 fs0 fc0 sc0 ls0 ws1">7</div><div class="t m0 x14 h2 y28 ff7 fs0 fc0 sc0 ls0 ws1"> <span class="_ _3"></span>K<span class="_ _1"></span>yung-Chang Kim and Choung-Seok Kim <span class="_ _3"></span> /  <span class="_ _3"></span>AASRI Pr<span class="_ _1"></span>ocedia <span class="_ _3"></span>  <span class="_ _3"></span>5 <span class="_ _3"></span> ( <span class="_ _3"></span>2013 <span class="_ _3"></span>)  <span class="_ _3"></span>2 – 8 </div><div class="t m0 x22 h4 y29 ff3 fs0 fc0 sc0 ls0 ws1"> </div><div class="t m0 x23 hc y2a ff3 fs8 fc0 sc0 ls1 ws9">We did not conduct expe<span class="_ _1"></span>riments on the query response <span class="ls2">ti<span class="_ _1"></span>me for the different <span class="_ _1"></span>join techniques for sensor </span></div><div class="t m0 x22 hc y53 ff3 fs8 fc0 sc0 ls2 wsb">networks. The reason is be<span class="_ _1"></span>cause we believe that the most important perform<span class="_ _1"></span>ance criterion for sensor </div><div class="t m0 x22 hc y2b ff3 fs8 fc0 sc0 ls0 ws19">networks is the total communicatio<span class="_ _2"></span>n cost. However, it is easy to observe that the query response time using<span class="_ _2"></span> </div><div class="t m0 x22 hc y2c ff3 fs8 fc0 sc0 ls1 ws3">the parallel version of our <span class="_ _1"></span>proposed algorithm is faster th<span class="ls2">an the ot<span class="_ _1"></span>her algorithms that are not based on parallel </span></div><div class="t m0 x22 hc y2d ff3 fs8 fc0 sc0 ls1 ws3">computing. Using our algorithm<span class="_ _1"></span>, the more sensor <span class="_ _1"></span>nodes are involved in query <span class="_ _1"></span>processing, the faster t<span class="_ _1"></span>he query </div><div class="t m0 x22 hc y2e ff3 fs8 fc0 sc0 ls0 ws3">response time since the join and data <span class="ws8">shipm<span class="_ _1"></span>ent can be all done in parallel. </span></div><div class="t m0 x22 hc y30 ff5 fs8 fc0 sc0 ls6 ws1">5.<span class="ff8 ls0"> </span><span class="ls2">Conclusion </span></div><div class="t m0 x23 hc y32 ff3 fs8 fc0 sc0 ls1 ws4">In this paper, we propose<span class="_ _1"></span>d a distributed algorithm<span class="_ _1"></span> <span class="ls2">for processing data in sensor networks. The proposed </span></div><div class="t m0 x22 hc y33 ff3 fs8 fc0 sc0 ls0 ws3">algorithm is based on a late materialized strategy in colum<span class="_ _1"></span>n-oriented database where the data tables are stored </div><div class="t m0 x22 hc y34 ff3 fs8 fc0 sc0 ls0 wsa">in columns. It is straightforward to convert the dist<span class="_ _1"></span><span class="ls2">ributed algorithm<span class="_ _1"></span> to a parallel version if we assume a </span></div><div class="t m0 x22 hc y35 ff3 fs8 fc0 sc0 ls2 wsa">shared-nothing architecture <span class="_ _1"></span>for the sensor networ<span class="_ _1"></span>k. The <span class="ls0 wsf">proposed algorithm<span class="_ _1"></span> is energy-efficient since only </span></div><div class="t m0 x22 hc y36 ff3 fs8 fc0 sc0 ls0 ws21">those co<span class="_ _2"></span>lumns and co<span class="_ _2"></span>lumn valu<span class="_ _2"></span>es involved<span class="_ _2"></span> in a query ar<span class="_ _2"></span>e shipped to s<span class="_ _2"></span>ensor nodes<span class="_ _2"></span> in the join r<span class="_ _2"></span>egion. Seve<span class="_ _2"></span>ral </div><div class="t m0 x22 hc y37 ff3 fs8 fc0 sc0 ls0 ws3">results were reported (e.g. SNJ, RFB) on the use of filtering techniques based on relational databases to <span class="_ _1"></span>prune </div><div class="t m0 x22 hc y38 ff3 fs8 fc0 sc0 ls0 wsf">unnecessary tuples be<span class="_ _1"></span>fore shipping the candidate tuples to the join re<span class="ls1">gion. A similar approach, based on </span></div><div class="t m0 x22 hc y39 ff3 fs8 fc0 sc0 ls0 ws1">column-oriented databases, was also proposed (e.g. EM).  </div><div class="t m0 x23 hc y3a ff3 fs8 fc0 sc0 ls2 ws8">Experimental results showed t<span class="_ _1"></span>hat our proposed algorithm<span class="_ _1"></span> outperforms the SNJ, RFB a<span class="_ _1"></span>nd EM algorithms in </div><div class="t m0 x22 hc y3b ff3 fs8 fc0 sc0 ls0 ws1a">terms of the communication cost. <span class="_ _1"></span>SNJ and the RFB algorithm<span class="_ _1"></span>s are based on relational databases and the EM </div><div class="t m0 x22 hc y3c ff3 fs8 fc0 sc0 ls2 ws1e">is based on column-oriented databases. To validate <span class="_ _1"></span>our experiment, we used different values<span class="_ _1"></span> of join </div><div class="t m0 x22 hc y3d ff3 fs8 fc0 sc0 ls0 ws4">selectivity as well as different table sizes. In perform<span class="_ _1"></span>ance analysis, we showed that the pe<span class="_ _1"></span>rformance of the </div><div class="t m0 x22 hc y3e ff3 fs8 fc0 sc0 ls0 ws5">proposed algorith<span class="_ _2"></span>m gets better as the join selectivity d<span class="_ _2"></span>ecrea<span class="ws1a">ses. In other words, if mo</span>re tuples are joined and </div><div class="t m0 x22 hc y3f ff3 fs8 fc0 sc0 ls2 ws5">output in the join result, the <span class="_ _1"></span>communication cost of t<span class="_ _1"></span>he proposed algorithm<span class="_ _1"></span> decreases. In addition, usi<span class="_ _1"></span>ng our </div><div class="t m0 x22 hc y40 ff3 fs8 fc0 sc0 ls0 ws4">algorithm, the more sensor nodes are involved in query processing, the faster the query respon<span class="_ _2"></span>se time since </div><div class="t m0 x22 hc y41 ff3 fs8 fc0 sc0 ls0 ws8">the join and data shipment<span class="ws3"> to the join nodes <span class="_ _1"></span>can be all done in parallel. </span></div><div class="t m0 x22 hc y80 ff5 fs8 fc0 sc0 ls2 ws1">Acknowledgements </div><div class="t m0 x23 hc y81 ff3 fs8 fc0 sc0 ls2 ws22">This research was su<span class="_ _1"></span>pported by Basic Science <span class="ls0">Research Program<span class="_ _1"></span> through the National <span class="_ _2"></span>Research </span></div><div class="t m0 x22 hc y82 ff3 fs8 fc0 sc0 ls0 ws18">Foundation of Korea (NRF) funded <span class="ws9">by the Ministry of E<span class="_ _1"></span>ducation, Scie<span class="ls2">nce and Technology (<span class="_ _1"></span>grant number </span></span></div><div class="t m0 x22 hc y83 ff3 fs8 fc0 sc0 ls0 ws1">2012-0007012) </div><div class="t m0 x22 hc y84 ff5 fs8 fc0 sc0 ls1 ws1">References </div><div class="t m0 x22 hc y85 ff3 fs8 fc0 sc0 ls2 ws8">[1] Madden, S.<span class="_ _1"></span> The design and evaluation <span class="_ _1"></span>of a query proces<span class="_ _1"></span>sing architecture for sensor <span class="_ _1"></span>networks. Ph.D. </div><div class="t m0 x22 hc y86 ff3 fs8 fc0 sc0 ls0 ws3">Thesis, UC Berkeley, CA 2003 </div><div class="t m0 x22 hc y87 ff3 fs8 fc0 sc0 ls0 ws8">[2] Coman, A.; Nascim<span class="_ _1"></span>ento, M.; Sander, J. On join location in sensor net<span class="_ _1"></span>works. In <span class="ff4 ls2 ws1">Proc<span class="_ _1"></span>eedings of Mobile </span></div><div class="t m0 x22 hc y88 ff4 fs8 fc0 sc0 ls4 ws1">Data Mana<span class="_ _1"></span>gement (MDM)<span class="_ _1"></span><span class="ff3 ls0 ws8"> , Mannheim, Germany, May 1, <span class="_ _1"></span>2007 </span></div><div class="t m0 x22 hc y89 ff3 fs8 fc0 sc0 ls1 ws8">[3] Yu, H., Li<span class="_ _1"></span>m, E., Zhang, J. On In-network Sy<span class="_ _1"></span>nopsis Jo<span class="ls0 ws3">in Processing for Sensor <span class="ws1">Net<span class="_ _1"></span>works. In: Proceedings </span></span></div><div class="t m0 x22 hc y8a ff3 fs8 fc0 sc0 ls1 ws8">of Mobile Data Managem<span class="_ _1"></span>ent, Nara, Japan, 2006 </div><div class="t m0 x22 hc y8b ff3 fs8 fc0 sc0 ls0 ws8">[4] Kim, K.C, Oh B. J. An Energy-Efficient <span class="_ _1"></span>Filtering Ap<span class="ws3">proach to In-Network Join Processing in Sensor </span></div><div class="t m0 x22 hc y8c ff3 fs8 fc0 sc0 ls0 ws1">Network Databases. In Proceedings of Multimedia, Comp<span class="ws3">uter Graphics and Broadcasting, Jeju, Korea, 2011 </span></div><div class="t m0 x22 hc y8d ff3 fs8 fc0 sc0 ls0 ws1">[5] Abadi, D.J., Myers, D.S., DeWitt,<span class="_ _2"></span> D.J., Ma<span class="ws8">dden, S.R. Materialization strategies in a column-oriented </span></div><div class="t m0 x22 hc y23 ff3 fs8 fc0 sc0 ls1 ws1">DBMS. In <span class="ff4 ls0">Proceedings of the International Conference on Data Engineering (ICDE)</span>, Ist<span class="_ _1"></span>anbul, Turkey, 2007. </div><div class="t m0 x22 hc y52 ff3 fs8 fc0 sc0 ls0 ws1">[6] Abadi, D.J., Madden, S.R., Hachem, N. Column-St<span class="ws8">ores vs. Row-Stores: How Differe<span class="_ _1"></span>nt Are They Really? </span></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf7" class="pf w0 h0" data-page-no="7"><div class="pc pc7 w0 h0"><img class="bi x15 y27 w3 he" alt="" src="bg7.png"/><div class="t m0 x0 h2 y28 ff1 fs0 fc0 sc0 ls0 ws1">8<span class="ff7">  <span class="_ _4"> </span> <span class="_ _3"></span>K<span class="_ _1"></span>yung-Chang Kim and Choung-Seok Kim <span class="_ _3"></span> /  <span class="_ _3"></span>AASRI Pr<span class="_ _1"></span>ocedia <span class="_ _3"></span>  <span class="_ _3"></span>5 <span class="_ _3"></span> ( <span class="_ _3"></span>2013 <span class="_ _3"></span>)  <span class="_ _3"></span>2 – 8 </span></div><div class="t m0 x16 h4 y29 ff3 fs0 fc0 sc0 ls0 ws1"> </div><div class="t m0 x16 hc y8e ff3 fs8 fc0 sc0 ls5 ws1">In <span class="ff4 ls2 ws2">Proceedings<span class="_ _1"></span> of ACM SIGMOD<span class="ff3 ls0 ws1">,<span class="ff5"> <span class="_ _1"></span><span class="ff3 ls4">Vancouver, Ca<span class="_ _1"></span>nada, 2008. </span></span></span></span></div><div class="t m0 x16 hc y8f ff3 fs8 fc0 sc0 ls2 ws8">[7] Kim, K.C, <span class="_ _1"></span>Kim  C. S. An Ener<span class="_ _1"></span>gy-Efficient Technique<span class="_ _1"></span><span class="ws2"> for Processi<span class="_ _1"></span>ng Sensor Data i<span class="_ _1"></span>n Wireless Sensor </span></div><div class="t m0 x16 hc y90 ff3 fs8 fc0 sc0 ls0 ws8">Networks. In: Proceedings of Ubiquitous Com<span class="_ _1"></span>puting and Multimedia Applications <span class="_ _1"></span>(UCMA), Bali, Indonesia </div><div class="t m0 x16 hc y91 ff3 fs8 fc0 sc0 ls0 ws1">2012 </div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
</div>
<div class="loading-indicator">
<img alt="" src="pdf2htmlEX-64x64.png">
</div>
</body>
</html>
