// Generated by CoffeeScript 1.6.3
var Promise, connect, connection, docTablesDefinition, error, exec, init, knex, logging, maxDbStrLength, purge, reinit, reqCounter, successCount, tableDefs, writeSentences;

logging = require('../../util/logging');

exec = require('../../util/exec');

Promise = require('bluebird');

docTablesDefinition = [
  {
    name: 'sentences',
    fields: {
      sentence: 'long-string'
    }
  }, {
    name: 'headers',
    fields: {
      header: 'short-string',
      level: 'natural-number'
    }
  }, {
    name: 'abstract',
    fields: {
      abstract: 'long-string'
    }
  }, {
    name: 'title',
    fields: {
      title: 'short-string'
    }
  }
];

docTablesDefinition.forEach(function(table) {
  return table.type = 'docTable';
});

tableDefs = docTablesDefinition;

tableDefs.forEach(function(table) {
  switch (table.type) {
    case 'docTable':
      table.fields.docName = 'short-string';
      return table.fields.runID = 'short-string';
  }
});

connection = {
  host: 'localhost',
  user: 'articlio',
  database: 'articlio',
  charset: 'utf8'
};

maxDbStrLength = 20000;

knex = require("knex")({
  dialect: "mysql",
  connection: process.env.DB_CONNECTION_STRING || connection
});

exports.connect = connect = function() {
  return knex = require("knex")({
    dialect: "mysql",
    connection: process.env.DB_CONNECTION_STRING || connection
  });
};

reqCounter = 0;

successCount = 0;

error = false;

writeSentences = function(context, dataType, data) {
  var mapping;
  reqCounter += 1;
  mapping = {
    sentence: data,
    docName: context.name,
    runID: context.runID
  };
  if (error) {
    logging.logRed('rdbms writing failed, now skipping all forthcoming rdbms writes.');
    return;
  }
  knex.insert(mapping).into(dataType)["catch"](function(error) {
    logging.logRed(error);
    console.dir(error);
    logging.logRed("writing to rdbms for data type " + dataType + " failed");
    error = true;
    return false;
  }).then(function(rows) {
    return successCount += 1;
  });
  return true;
};

exports.write = function(context, dataType, data) {
  var inputFileName;
  inputFileName = context;
  switch (dataType) {
    case 'sentences':
      return writeSentences(context, dataType, data);
  }
};

purge = function() {
  return tableDefs.forEach(function(table) {
    return knex.schema.dropTableIfExists(table.name);
  });
};

init = function() {
  var tableHandler, tablesCreated;
  tableHandler = function(tableDef, table) {
    var field, type;
    for (field in tableDef.fields) {
      type = tableDef.fields[field];
      switch (type) {
        case 'short-string':
          table.string(field);
          break;
        case 'long-string':
          table.string(field, maxDbStrLength);
          break;
        case 'natural-number':
          table.integer(field);
          break;
        default:
          error = "unidentified field type " + field + " specified in table definition of table " + tableDef.name;
          logging.logRed(error);
          throw error;
      }
    }
    return true;
  };
  tablesCreated = tableDefs.map(function(tableDef) {
    var boundTableHandler;
    boundTableHandler = tableHandler.bind(void 0, tableDef);
    return knex.schema.createTable(tableDef.name, boundTableHandler);
  });
  return Promise.all(tablesCreated).then(function() {
    knex.destroy(function() {});
    return console.log('database ready for action');
  })["catch"](function(error) {
    logging.logRed('database reinitialization failed');
    return false;
  });
};

exports.reinit = reinit = function() {
  return exec('src/storage/rdbms/rdbms-recreate.sh', null, function(success) {
    if (success) {
      console.log('database definition and database user clean and ready');
      return init();
    } else {
      return console.error('database reinitialization failed - could not recreate database or database user');
    }
  });
};
