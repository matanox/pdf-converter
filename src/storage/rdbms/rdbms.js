// Generated by CoffeeScript 1.6.3
var Promise, connect, connection, diffsTable, docTablesDefinition, error, exec, init, knex, logging, maxDbStrLength, purge, reinit, reqCounter, successCount, tableDefs, write;

logging = require('../../util/logging');

exec = require('../../util/exec');

Promise = require('bluebird');

docTablesDefinition = [
  {
    name: 'sentences',
    fields: {
      sentence: 'long-string'
    }
  }, {
    name: 'abstract',
    fields: {
      abstract: 'long-string'
    }
  }, {
    name: 'title',
    fields: {
      title: 'short-string'
    }
  }, {
    name: 'headers',
    fields: {
      level: 'natural-number',
      tokenId: 'natural-number',
      header: 'short-string',
      detectionComment: 'short-string'
    }
  }, {
    name: 'properties',
    fields: {
      propName: 'short-string',
      propValue: 'short-string'
    }
  }
];

docTablesDefinition.forEach(function(table) {
  return table.type = 'docTable';
});

diffsTable = [
  {
    type: 'diffs',
    name: 'diffs',
    fields: {
      docName: 'short-string',
      dataType: 'short-string',
      editDistance: 'natural-number',
      SESlink: 'short-string',
      run1ID: 'short-string',
      run2ID: 'short-string',
      run1link: 'short-string',
      run2link: 'short-string'
    }
  }
];

tableDefs = docTablesDefinition.concat(diffsTable);

tableDefs.forEach(function(table) {
  switch (table.type) {
    case 'docTable':
      table.fields.docName = 'short-string';
      return table.fields.runID = 'short-string';
  }
});

connection = {
  host: 'localhost',
  user: 'articlio',
  database: 'articlio',
  charset: 'utf8'
};

maxDbStrLength = 20000;

knex = require("knex")({
  dialect: "mysql",
  connection: process.env.DB_CONNECTION_STRING || connection
});

exports.connect = connect = function() {
  return knex = require("knex")({
    dialect: "mysql",
    connection: process.env.DB_CONNECTION_STRING || connection
  });
};

reqCounter = 0;

successCount = 0;

error = false;

write = function(context, dataType, mapping, data) {
  reqCounter += 1;
  if (error) {
    logging.logRed('rdbms writing failed, now skipping all forthcoming rdbms writes.');
    return;
  }
  knex.insert(mapping).into(dataType)["catch"](function(error) {
    logging.logRed(error);
    console.dir(error);
    logging.logRed("writing to rdbms for data type " + dataType + " failed");
    error = true;
    return false;
  }).then(function(rows) {
    return successCount += 1;
  });
  return true;
};

exports.write = function(context, dataType, data) {
  var inputFileName, key, mapping;
  inputFileName = context;
  switch (dataType) {
    case 'sentences':
      mapping = {
        sentence: data,
        docName: context.name,
        runID: context.runID
      };
      return write(context, dataType, mapping, data);
    case 'abstract':
      mapping = {
        abstract: data,
        docName: context.name,
        runID: context.runID
      };
      return write(context, dataType, mapping, data);
    case 'title':
      mapping = {
        title: data,
        docName: context.name,
        runID: context.runID
      };
      return write(context, dataType, mapping, data);
    case 'headers':
      mapping = {
        docName: context.name,
        runID: context.runID
      };
      for (key in data) {
        mapping[key] = data[key];
      }
      return write(context, dataType, mapping, data);
    case 'diffs':
      mapping = {};
      for (key in data) {
        mapping[key] = data[key];
      }
      return write(context, dataType, mapping, data);
  }
};

purge = function() {
  return tableDefs.forEach(function(table) {
    return knex.schema.dropTableIfExists(table.name);
  });
};

init = function() {
  var tableHandler, tablesCreated;
  tableHandler = function(tableDef, table) {
    var field, type;
    for (field in tableDef.fields) {
      type = tableDef.fields[field];
      switch (type) {
        case 'short-string':
          table.string(field);
          break;
        case 'long-string':
          table.string(field, maxDbStrLength);
          break;
        case 'natural-number':
          table.integer(field);
          break;
        default:
          error = "unidentified field type " + field + " specified in table definition of table " + tableDef.name;
          logging.logRed(error);
          throw error;
      }
    }
    return true;
  };
  tablesCreated = tableDefs.map(function(tableDef) {
    var boundTableHandler;
    boundTableHandler = tableHandler.bind(void 0, tableDef);
    return knex.schema.createTable(tableDef.name, boundTableHandler);
  });
  return Promise.all(tablesCreated).then(function() {
    knex.destroy(function() {});
    return console.log('database ready for action');
  })["catch"](function(error) {
    logging.logRed('database reinitialization failed');
    return false;
  });
};

exports.reinit = reinit = function() {
  return exec('src/storage/rdbms/rdbms-recreate.sh', null, function(success) {
    if (success) {
      console.log('database definition and database user clean and ready');
      return init();
    } else {
      return console.error('database reinitialization failed - could not recreate database or database user');
    }
  });
};
