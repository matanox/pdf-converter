// Generated by CoffeeScript 1.6.3
var Promise, connect, connection, dataMap, diffsTable, docTablesDefinition, error, exec, init, knex, logging, maxDbStrLength, purge, reinit, reqCounter, runIDsTableDef, runsTableDef, successCount, tableDefs, write;

logging = require('../../util/logging');

exec = require('../../util/exec');

Promise = require('bluebird');

docTablesDefinition = [
  {
    name: 'sentences',
    fields: {
      sentence: 'long-string'
    }
  }, {
    name: 'abstract',
    fields: {
      abstract: 'long-string'
    }
  }, {
    name: 'title',
    fields: {
      title: 'short-string'
    }
  }, {
    name: 'headers',
    fields: {
      level: 'natural-number',
      tokenId: 'natural-number',
      header: 'short-string',
      detectionComment: 'short-string'
    }
  }, {
    name: 'properties',
    fields: {
      propName: 'short-string',
      propValue: 'short-string'
    }
  }
];

docTablesDefinition.forEach(function(table) {
  return table.type = 'docTable';
});

diffsTable = [
  {
    type: 'diffs',
    name: 'diffs',
    fields: {
      docName: 'short-string',
      dataType: 'short-string',
      editDistance: 'natural-number',
      SESlink: 'short-string',
      run1ID: 'short-string',
      run2ID: 'short-string',
      run1link: 'short-string',
      run2link: 'short-string'
    }
  }
];

runIDsTableDef = [
  {
    type: 'runIDs',
    name: 'runIDs',
    fields: {
      order: 'auto-increment',
      runID: 'short-string'
    }
  }
];

runsTableDef = [
  {
    type: 'runs',
    name: 'runs',
    fields: {
      docName: 'short-string',
      runID: 'short-string',
      status: 'short-string',
      statusDetail: 'short-string'
    }
  }
];

tableDefs = docTablesDefinition.concat(diffsTable, runIDsTableDef, runsTableDef);

tableDefs.forEach(function(table) {
  switch (table.type) {
    case 'docTable':
      table.fields.docName = 'short-string';
      return table.fields.runID = 'short-string';
  }
});

connection = {
  host: 'localhost',
  user: 'articlio',
  database: 'articlio',
  charset: 'utf8'
};

maxDbStrLength = 20000;

knex = require("knex")({
  dialect: "mysql",
  connection: process.env.DB_CONNECTION_STRING || connection
});

exports.connect = connect = function() {
  return knex = require("knex")({
    dialect: "mysql",
    connection: process.env.DB_CONNECTION_STRING || connection
  });
};

reqCounter = 0;

successCount = 0;

error = false;

write = function(context, dataType, mapping) {
  reqCounter += 1;
  /*
  if error 
    logging.logRed 'rdbms writing failed, now skipping all forthcoming rdbms writes.'
    return
  */

  knex.insert(mapping).into(dataType)["catch"](function(error) {
    logging.logRed(error);
    console.dir(error);
    logging.logRed("writing to rdbms for data type " + dataType + " failed");
    error = true;
    return false;
  }).then(function(rows) {
    return successCount += 1;
  });
  return true;
};

dataMap = function(context, dataType, data) {
  var key, mapping;
  switch (dataType) {
    case 'sentences':
      mapping = {
        sentence: data,
        docName: context.name,
        runID: context.runID
      };
      return mapping;
    case 'abstract':
      mapping = {
        abstract: data,
        docName: context.name,
        runID: context.runID
      };
      return mapping;
    case 'title':
      mapping = {
        title: data,
        docName: context.name,
        runID: context.runID
      };
      return mapping;
    case 'headers':
      mapping = {
        docName: context.name,
        runID: context.runID
      };
      for (key in data) {
        mapping[key] = data[key];
      }
      return mapping;
    default:
      mapping = {};
      for (key in data) {
        mapping[key] = data[key];
      }
      return mapping;
  }
};

/*
    when 'diffs'
      mapping = {}
      for key of data
        mapping[key] = data[key]

      return mapping

    when 'bulkRuns'
      mapping = {}
      for key of data
        mapping[key] = data[key]

      return mapping
*/


exports.write = function(context, dataType, data) {
  var dataArray, inputFileName, mapping;
  inputFileName = context;
  if (Array.isArray(data)) {
    dataArray = data;
    mapping = dataArray.map(function(data) {
      return dataMap(context, dataType, data);
    });
  } else {
    mapping = dataMap(context, dataType, data);
  }
  if (mapping != null) {
    return write(context, dataType, mapping);
  }
};

purge = function() {
  return tableDefs.forEach(function(table) {
    return knex.schema.dropTableIfExists(table.name);
  });
};

init = function() {
  var tableHandler, tablesCreated;
  tableHandler = function(tableDef, table) {
    var field, type;
    for (field in tableDef.fields) {
      type = tableDef.fields[field];
      logging.logYellow("field: " + field + " | type: " + type);
      switch (type) {
        case 'short-string':
          table.string(field);
          break;
        case 'long-string':
          table.string(field, maxDbStrLength);
          break;
        case 'natural-number':
          table.integer(field);
          break;
        case 'auto-increment':
          table.increments(field);
          break;
        default:
          error = "unidentified field type " + field + " specified in table definition of table " + tableDef.name;
          logging.logRed(error);
          throw error;
      }
    }
    return true;
  };
  tablesCreated = tableDefs.map(function(tableDef) {
    var boundTableHandler;
    boundTableHandler = tableHandler.bind(void 0, tableDef);
    return knex.schema.createTable(tableDef.name, boundTableHandler);
  });
  return Promise.all(tablesCreated).then(function() {
    knex.destroy(function() {});
    console.log('database tables created');
    return console.log('database ready for action');
  })["catch"](function(error) {
    logging.logRed('tables creation failed');
    logging.logRed('database reinitialization failed');
    throw error;
  });
};

exports.reinit = reinit = function() {
  return exec('src/storage/rdbms/rdbms-recreate.sh', null, function(success) {
    if (success) {
      console.log('database definition and database user clean and ready');
      return init();
    } else {
      return console.error('database reinitialization failed - could not recreate database or database user');
    }
  });
};

exports.query = function() {
  return knex('bulkRuns').max('order').then(function(lastBulkRun) {
    return knex.select('runID').from('bulkRuns').where({
      order: lastBulkRun
    });
  }).then(function(runID) {}, knex.select('sentence').from('sentences').where({
    docID: docID
  })).then();
};
