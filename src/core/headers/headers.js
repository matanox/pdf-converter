// Generated by CoffeeScript 1.6.3
var dataWriter, expected, getContinuouslyStyled, hasExpectedsequence, hasNext, isTitlishCase, isTitlishCaseSequence, logging, noHeadersDocs, optionallyCasedInTitle, sameness, separateness, startsWithDigit, styleContinuity, test, testNext, tripleIterator,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

dataWriter = require('../../data/dataWriter');

logging = require('../../util/logging');

expected = require('./expected');

noHeadersDocs = 0;

tripleIterator = function(tokens, func) {
  var curr, i, next, prev, _results;
  i = 1;
  _results = [];
  while (i < tokens.length - 1) {
    prev = tokens[i - 1];
    curr = tokens[i];
    next = tokens[i + 1];
    func(prev, curr, next);
    _results.push(i = i + 1);
  }
  return _results;
};

separateness = function(first, second) {
  if (first.finalStyles['font-size'] !== second.finalStyles['font-size']) {
    return true;
  }
  if (first.finalStyles['font-family'] !== second.finalStyles['font-family']) {
    return true;
  }
  return false;
};

sameness = function(first, second) {
  return !separateness(first, second);
};

styleContinuity = sameness;

getContinuouslyStyled = function(tokens, t) {
  var ender;
  while (t + 1 < tokens.length && styleContinuity(tokens[t], tokens[t + 1])) {
    ender = t + 1;
    t += 1;
  }
  return ender;
};

test = function(tokens, t, f) {
  return t < tokens.length && f(tokens[t]);
};

testNext = function(tokens, t, f) {
  if (test(tokens, t + 1, function(token) {
    return token.metaType === 'delimiter';
  })) {
    if (test(tokens, t + 2, function(token) {
      return token.metaType === 'regular';
    })) {
      if (f(tokens[t + 2])) {
        return true;
      }
    }
  }
  return false;
};

hasNext = function(tokens, t, f) {
  if (test(tokens, t + 1, function(token) {
    return token.metaType === 'delimiter';
  })) {
    if (test(tokens, t + 2, function(token) {
      return token.metaType === 'regular';
    })) {
      return true;
    }
  }
  return false;
};

optionallyCasedInTitle = ['and', 'for', 'in', 'of', 'the'];

isTitlishCase = function(token) {
  var _ref, _ref1;
  return ((_ref = token["case"]) === 'upper' || _ref === 'title') || !isNaN(parseFloat(token.text)) || (_ref1 = token.text, __indexOf.call(optionallyCasedInTitle, _ref1) >= 0);
};

isTitlishCaseSequence = function(tokens, start, end) {
  var t, _i;
  for (t = _i = start; start <= end ? _i <= end : _i >= end; t = start <= end ? ++_i : --_i) {
    if (tokens[t].metaType === 'regular' && !isTitlishCase(tokens[t])) {
      return false;
    }
  }
  return true;
};

startsWithDigit = function(text) {
  return [1, 2, 3, 4, 5, 6, 7, 8, 9].some(function(i) {
    return parseInt(text.charAt(0)) === i;
  });
};

hasExpectedsequence = function(text) {
  var e, found, _i, _len;
  found = false;
  for (_i = 0, _len = expected.length; _i < _len; _i++) {
    e = expected[_i];
    if (text.indexOf(e) > -1) {
      found = true;
    }
  }
  return found;
};

module.exports = function(context, tokens) {
  var anyFound, detectionComments, getLevelStyle, h, headers, level1Style, prev, regularTokens, seqEnd, sequenceAsText, t, token, _i, _j, _len;
  getLevelStyle = function(token) {
    var levelStyle;
    return levelStyle = {
      finalStyles: {
        "font-size": token.finalStyles['font-size'],
        "font-family": token.finalStyles['font-family']
      }
    };
  };
  anyFound = false;
  headers = [];
  regularTokens = tokens.filter(function(token) {
    return token.metaType === 'regular';
  });
  for (t = _i = 0, _len = tokens.length; _i < _len; t = ++_i) {
    token = tokens[t];
    if (t < tokens.length) {
      prev = tokens[t - 1];
    }
    /*
    if token.text? and token.text is 'References'
      console.dir tokens[t-1]
      logging.logBlue "References token:"
      console.dir token
    */

    if (token.paragraphOpener) {
      if (!separateness(prev, token)) {
        continue;
      }
      sequenceAsText = '';
      seqEnd = getContinuouslyStyled(tokens, t);
      for (h = _j = t; t <= seqEnd ? _j <= seqEnd : _j >= seqEnd; h = t <= seqEnd ? ++_j : --_j) {
        sequenceAsText += tokens[h].metaType === 'regular' ? tokens[h].text : ' ';
      }
      if (!isTitlishCaseSequence(tokens, t, seqEnd)) {
        continue;
      }
      if (sequenceAsText.indexOf("Introduction") > -1) {
        logging.logBlue('level1 style captured');
        level1Style = getLevelStyle(token);
      }
      if (!(hasExpectedsequence(sequenceAsText) || ((level1Style != null) && sameness(token, level1Style)))) {
        continue;
      }
      detectionComments = [];
      if (hasExpectedsequence(sequenceAsText)) {
        detectionComments.push('expected header text');
      }
      if ((level1Style != null) && sameness(token, level1Style)) {
        detectionComments.push('mirrors introduction header style');
      }
      anyFound = true;
      dataWriter.write(context, 'headers', {
        tokenId: token.id,
        header: sequenceAsText,
        level: 1,
        detectionComment: detectionComments.join(" & ")
      });
      logging.logBlue("detected header - " + detectionComments.join(" & ") + ": " + sequenceAsText);
    }
  }
  if (!anyFound) {
    noHeadersDocs += 1;
    return logging.logRed("no headers detected for " + context.name + " (" + noHeadersDocs + " total)");
  }
};
